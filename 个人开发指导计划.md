# TaskFlow项目个人开发指导计划

## 🎯 项目基本信息

### 开发配置
- **开发人员**：1人全职开发
- **开发周期**：16周（调整后，考虑学习成本）
- **云服务**：阿里云
- **监控方案**：Prometheus + Grafana
- **部署方案**：Docker + Kubernetes
- **测试策略**：自动化测试（我来指导）

### 学习重点
- **Code Review**：我来教你规范和最佳实践
- **部署策略**：蓝绿部署、滚动更新等（实践中学习）
- **备份恢复**：数据库备份和恢复方案（实践中学习）
- **K8s部署**：从基础到生产级部署

## 📅 调整后的开发阶段

### 阶段1：环境搭建和基础框架（Week 1-3）
**目标**：搭建完整开发环境，掌握基础工具

### 阶段2：核心领域实现（Week 4-8）
**目标**：实现用户、项目、任务核心功能

### 阶段3：高级功能开发（Week 9-12）
**目标**：权限系统、文件管理、搜索功能

### 阶段4：测试和优化（Week 13-14）
**目标**：完整测试体系、性能优化

### 阶段5：部署和上线（Week 15-16）
**目标**：生产环境部署、监控配置

---

## 🚀 Week 1：项目初始化和环境搭建

### 本周目标
- 搭建项目基础框架
- 配置开发环境
- 学习基础工具使用

### Day 1-2：项目结构搭建

#### 步骤1：创建项目目录
```bash
# 创建项目根目录
mkdir taskflow
cd taskflow

# 初始化Go模块
go mod init github.com/taskflow/taskflow

# 创建基础目录结构
mkdir -p cmd/api
mkdir -p internal/{domain,application,infrastructure,interfaces}
mkdir -p internal/domain/{user,project,task,shared}
mkdir -p internal/application/{user,project,task,shared}
mkdir -p internal/infrastructure/{persistence,messaging,config}
mkdir -p internal/interfaces/{http,cli}
mkdir -p pkg/{logger,errors,utils,constants}
mkdir -p configs
mkdir -p scripts
mkdir -p test/{unit,integration,e2e}
mkdir -p docs
mkdir -p deployments/{docker,kubernetes}
```

#### 步骤2：创建基础配置文件

**go.mod 依赖管理**
```go
module github.com/taskflow/taskflow

go 1.21

require (
    github.com/gin-gonic/gin v1.9.1
    github.com/golang-jwt/jwt/v5 v5.0.0
    github.com/google/uuid v1.3.0
    github.com/google/wire v0.5.0
    github.com/spf13/viper v1.16.0
    go.uber.org/zap v1.24.0
    gorm.io/driver/mysql v1.5.1
    gorm.io/gorm v1.25.2
    github.com/go-redis/redis/v8 v8.11.5
    github.com/swaggo/gin-swagger v1.6.0
    github.com/swaggo/swag v1.16.1
    github.com/go-playground/validator/v10 v10.14.1
    github.com/stretchr/testify v1.8.4
)
```

**配置文件 configs/config.yaml**
```yaml
# 应用配置
app:
  name: "TaskFlow"
  version: "1.0.0"
  port: 8080
  mode: "development" # development, testing, production
  
# 数据库配置
database:
  driver: "mysql"
  host: "localhost"
  port: 3306
  username: "taskflow"
  password: "taskflow123"
  database: "taskflow"
  charset: "utf8mb4"
  parse_time: true
  loc: "Local"
  max_idle_conns: 10
  max_open_conns: 100
  conn_max_lifetime: 3600 # 秒

# Redis配置
redis:
  host: "localhost"
  port: 6379
  password: ""
  database: 0
  pool_size: 10
  min_idle_conns: 5

# JWT配置
jwt:
  secret: "your-super-secret-jwt-key-change-in-production"
  expire_hours: 24
  refresh_expire_hours: 168 # 7天

# 日志配置
log:
  level: "debug" # debug, info, warn, error
  format: "json" # json, text
  output: "stdout" # stdout, file
  file_path: "logs/app.log"
  max_size: 100 # MB
  max_backups: 7
  max_age: 30 # 天

# 文件上传配置
upload:
  max_size: 10485760 # 10MB
  allowed_types: ["jpg", "jpeg", "png", "pdf", "doc", "docx"]
  storage_path: "uploads"
  chunk_size: 1048576 # 1MB
```

#### 步骤3：创建Docker开发环境

**docker-compose.dev.yml**
```yaml
version: '3.8'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: taskflow-mysql
    restart: unless-stopped
    environment:
      MYSQL_ROOT_PASSWORD: rootpass
      MYSQL_DATABASE: taskflow
      MYSQL_USER: taskflow
      MYSQL_PASSWORD: taskflow123
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./scripts/init.sql:/docker-entrypoint-initdb.d/init.sql
    networks:
      - taskflow-network

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: taskflow-redis
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    networks:
      - taskflow-network

  # 应用服务（开发环境）
  app:
    build:
      context: .
      dockerfile: scripts/docker/Dockerfile.dev
    container_name: taskflow-app
    restart: unless-stopped
    ports:
      - "8080:8080"
    volumes:
      - .:/app
      - /app/vendor
    environment:
      - ENV=development
      - DB_HOST=mysql
      - REDIS_HOST=redis
    depends_on:
      - mysql
      - redis
    networks:
      - taskflow-network

volumes:
  mysql_data:
  redis_data:

networks:
  taskflow-network:
    driver: bridge
```

**Dockerfile.dev**
```dockerfile
# scripts/docker/Dockerfile.dev
FROM golang:1.21-alpine AS development

# 安装必要工具
RUN apk add --no-cache git

# 设置工作目录
WORKDIR /app

# 安装热重载工具
RUN go install github.com/cosmtrek/air@latest

# 复制go mod文件
COPY go.mod go.sum ./

# 下载依赖
RUN go mod download

# 复制源代码
COPY . .

# 暴露端口
EXPOSE 8080

# 使用air进行热重载
CMD ["air", "-c", ".air.toml"]
```

**Air配置文件 .air.toml**
```toml
root = "."
testdata_dir = "testdata"
tmp_dir = "tmp"

[build]
  args_bin = []
  bin = "./tmp/main"
  cmd = "go build -o ./tmp/main ./cmd/api"
  delay = 0
  exclude_dir = ["assets", "tmp", "vendor", "testdata"]
  exclude_file = []
  exclude_regex = ["_test.go"]
  exclude_unchanged = false
  follow_symlink = false
  full_bin = ""
  include_dir = []
  include_ext = ["go", "tpl", "tmpl", "html"]
  include_file = []
  kill_delay = "0s"
  log = "build-errors.log"
  poll = false
  poll_interval = 0
  rerun = false
  rerun_delay = 500
  send_interrupt = false
  stop_on_root = false

[color]
  app = ""
  build = "yellow"
  main = "magenta"
  runner = "green"
  watcher = "cyan"

[log]
  main_only = false
  time = false

[misc]
  clean_on_exit = false

[screen]
  clear_on_rebuild = false
  keep_scroll = true
```

### Day 3-4：基础配置和工具类

#### 步骤4：配置管理

**internal/infrastructure/config/config.go**
```go
package config

import (
    "fmt"
    "github.com/spf13/viper"
)

type Config struct {
    App      AppConfig      `mapstructure:"app"`
    Database DatabaseConfig `mapstructure:"database"`
    Redis    RedisConfig    `mapstructure:"redis"`
    JWT      JWTConfig      `mapstructure:"jwt"`
    Log      LogConfig      `mapstructure:"log"`
    Upload   UploadConfig   `mapstructure:"upload"`
}

type AppConfig struct {
    Name    string `mapstructure:"name"`
    Version string `mapstructure:"version"`
    Port    int    `mapstructure:"port"`
    Mode    string `mapstructure:"mode"`
}

type DatabaseConfig struct {
    Driver          string `mapstructure:"driver"`
    Host            string `mapstructure:"host"`
    Port            int    `mapstructure:"port"`
    Username        string `mapstructure:"username"`
    Password        string `mapstructure:"password"`
    Database        string `mapstructure:"database"`
    Charset         string `mapstructure:"charset"`
    ParseTime       bool   `mapstructure:"parse_time"`
    Loc             string `mapstructure:"loc"`
    MaxIdleConns    int    `mapstructure:"max_idle_conns"`
    MaxOpenConns    int    `mapstructure:"max_open_conns"`
    ConnMaxLifetime int    `mapstructure:"conn_max_lifetime"`
}

type RedisConfig struct {
    Host         string `mapstructure:"host"`
    Port         int    `mapstructure:"port"`
    Password     string `mapstructure:"password"`
    Database     int    `mapstructure:"database"`
    PoolSize     int    `mapstructure:"pool_size"`
    MinIdleConns int    `mapstructure:"min_idle_conns"`
}

type JWTConfig struct {
    Secret             string `mapstructure:"secret"`
    ExpireHours        int    `mapstructure:"expire_hours"`
    RefreshExpireHours int    `mapstructure:"refresh_expire_hours"`
}

type LogConfig struct {
    Level      string `mapstructure:"level"`
    Format     string `mapstructure:"format"`
    Output     string `mapstructure:"output"`
    FilePath   string `mapstructure:"file_path"`
    MaxSize    int    `mapstructure:"max_size"`
    MaxBackups int    `mapstructure:"max_backups"`
    MaxAge     int    `mapstructure:"max_age"`
}

type UploadConfig struct {
    MaxSize      int64    `mapstructure:"max_size"`
    AllowedTypes []string `mapstructure:"allowed_types"`
    StoragePath  string   `mapstructure:"storage_path"`
    ChunkSize    int      `mapstructure:"chunk_size"`
}

// LoadConfig 加载配置文件
func LoadConfig(path string) (*Config, error) {
    viper.AddConfigPath(path)
    viper.SetConfigName("config")
    viper.SetConfigType("yaml")

    // 自动读取环境变量
    viper.AutomaticEnv()

    if err := viper.ReadInConfig(); err != nil {
        return nil, fmt.Errorf("failed to read config file: %w", err)
    }

    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, fmt.Errorf("failed to unmarshal config: %w", err)
    }

    return &config, nil
}

// GetDSN 获取数据库连接字符串
func (c *DatabaseConfig) GetDSN() string {
    return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?charset=%s&parseTime=%t&loc=%s",
        c.Username, c.Password, c.Host, c.Port, c.Database, 
        c.Charset, c.ParseTime, c.Loc)
}
```

#### 步骤5：日志系统

**pkg/logger/logger.go**
```go
package logger

import (
    "os"
    "go.uber.org/zap"
    "go.uber.org/zap/zapcore"
    "gopkg.in/natefinch/lumberjack.v2"
)

var Logger *zap.Logger

type Config struct {
    Level      string
    Format     string
    Output     string
    FilePath   string
    MaxSize    int
    MaxBackups int
    MaxAge     int
}

// InitLogger 初始化日志器
func InitLogger(config *Config) error {
    // 设置日志级别
    level := zapcore.InfoLevel
    switch config.Level {
    case "debug":
        level = zapcore.DebugLevel
    case "info":
        level = zapcore.InfoLevel
    case "warn":
        level = zapcore.WarnLevel
    case "error":
        level = zapcore.ErrorLevel
    }

    // 设置编码器
    var encoder zapcore.Encoder
    encoderConfig := zapcore.EncoderConfig{
        TimeKey:        "timestamp",
        LevelKey:       "level",
        NameKey:        "logger",
        CallerKey:      "caller",
        FunctionKey:    zapcore.OmitKey,
        MessageKey:     "message",
        StacktraceKey:  "stacktrace",
        LineEnding:     zapcore.DefaultLineEnding,
        EncodeLevel:    zapcore.LowercaseLevelEncoder,
        EncodeTime:     zapcore.ISO8601TimeEncoder,
        EncodeDuration: zapcore.SecondsDurationEncoder,
        EncodeCaller:   zapcore.ShortCallerEncoder,
    }

    if config.Format == "json" {
        encoder = zapcore.NewJSONEncoder(encoderConfig)
    } else {
        encoder = zapcore.NewConsoleEncoder(encoderConfig)
    }

    // 设置输出
    var writer zapcore.WriteSyncer
    if config.Output == "file" {
        writer = zapcore.AddSync(&lumberjack.Logger{
            Filename:   config.FilePath,
            MaxSize:    config.MaxSize,
            MaxBackups: config.MaxBackups,
            MaxAge:     config.MaxAge,
            Compress:   true,
        })
    } else {
        writer = zapcore.AddSync(os.Stdout)
    }

    // 创建核心
    core := zapcore.NewCore(encoder, writer, level)

    // 创建日志器
    Logger = zap.New(core, zap.AddCaller(), zap.AddStacktrace(zapcore.ErrorLevel))

    return nil
}

// 便捷方法
func Debug(msg string, fields ...zap.Field) {
    Logger.Debug(msg, fields...)
}

func Info(msg string, fields ...zap.Field) {
    Logger.Info(msg, fields...)
}

func Warn(msg string, fields ...zap.Field) {
    Logger.Warn(msg, fields...)
}

func Error(msg string, fields ...zap.Field) {
    Logger.Error(msg, fields...)
}

func Fatal(msg string, fields ...zap.Field) {
    Logger.Fatal(msg, fields...)
}
```

#### 步骤6：错误处理

**pkg/errors/errors.go**
```go
package errors

import (
    "fmt"
    "net/http"
)

// 领域错误类型
type DomainError struct {
    Code    string `json:"code"`
    Message string `json:"message"`
    Details string `json:"details,omitempty"`
}

func (e *DomainError) Error() string {
    return e.Message
}

// 应用错误类型
type AppError struct {
    Type       string `json:"type"`
    Message    string `json:"message"`
    StatusCode int    `json:"status_code"`
    Err        error  `json:"-"`
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("%s: %v", e.Message, e.Err)
    }
    return e.Message
}

// 错误构造函数
func NewDomainError(code, message string) *DomainError {
    return &DomainError{
        Code:    code,
        Message: message,
    }
}

func NewValidationError(message string) *AppError {
    return &AppError{
        Type:       "validation_error",
        Message:    message,
        StatusCode: http.StatusBadRequest,
    }
}

func NewPermissionDeniedError(message string) *AppError {
    return &AppError{
        Type:       "permission_denied",
        Message:    message,
        StatusCode: http.StatusForbidden,
    }
}

func NewNotFoundError(message string) *AppError {
    return &AppError{
        Type:       "not_found",
        Message:    message,
        StatusCode: http.StatusNotFound,
    }
}

func NewInternalError(message string, err error) *AppError {
    return &AppError{
        Type:       "internal_error",
        Message:    message,
        StatusCode: http.StatusInternalServerError,
        Err:        err,
    }
}

// 业务错误常量
var (
    ErrUserNotFound     = NewDomainError("USER_NOT_FOUND", "用户不存在")
    ErrUserExists       = NewDomainError("USER_EXISTS", "用户已存在")
    ErrInvalidPassword  = NewDomainError("INVALID_PASSWORD", "密码错误")
    ErrProjectNotFound  = NewDomainError("PROJECT_NOT_FOUND", "项目不存在")
    ErrTaskNotFound     = NewDomainError("TASK_NOT_FOUND", "任务不存在")
    ErrInvalidStatus    = NewDomainError("INVALID_STATUS", "无效的状态转换")
    ErrPermissionDenied = NewDomainError("PERMISSION_DENIED", "权限不足")
)
```

### Day 5：数据库连接和基础模型

#### 步骤7：数据库连接

**internal/infrastructure/persistence/mysql/connection.go**
```go
package mysql

import (
    "fmt"
    "time"
    "gorm.io/driver/mysql"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
    "github.com/taskflow/internal/infrastructure/config"
    appLogger "github.com/taskflow/pkg/logger"
)

// NewDatabase 创建数据库连接
func NewDatabase(config *config.DatabaseConfig) (*gorm.DB, error) {
    dsn := config.GetDSN()
    
    db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    if err != nil {
        return nil, fmt.Errorf("failed to connect to database: %w", err)
    }

    // 获取底层的sql.DB
    sqlDB, err := db.DB()
    if err != nil {
        return nil, fmt.Errorf("failed to get underlying sql.DB: %w", err)
    }

    // 设置连接池参数
    sqlDB.SetMaxIdleConns(config.MaxIdleConns)
    sqlDB.SetMaxOpenConns(config.MaxOpenConns)
    sqlDB.SetConnMaxLifetime(time.Duration(config.ConnMaxLifetime) * time.Second)

    // 测试连接
    if err := sqlDB.Ping(); err != nil {
        return nil, fmt.Errorf("failed to ping database: %w", err)
    }

    appLogger.Info("Database connected successfully")
    return db, nil
}
```

#### 步骤8：创建主程序入口

**cmd/api/main.go**
```go
package main

import (
    "context"
    "fmt"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/taskflow/internal/infrastructure/config"
    "github.com/taskflow/internal/infrastructure/persistence/mysql"
    "github.com/taskflow/pkg/logger"
)

func main() {
    // 加载配置
    cfg, err := config.LoadConfig("./configs")
    if err != nil {
        panic(fmt.Sprintf("Failed to load config: %v", err))
    }

    // 初始化日志
    if err := logger.InitLogger(&logger.Config{
        Level:      cfg.Log.Level,
        Format:     cfg.Log.Format,
        Output:     cfg.Log.Output,
        FilePath:   cfg.Log.FilePath,
        MaxSize:    cfg.Log.MaxSize,
        MaxBackups: cfg.Log.MaxBackups,
        MaxAge:     cfg.Log.MaxAge,
    }); err != nil {
        panic(fmt.Sprintf("Failed to initialize logger: %v", err))
    }

    logger.Info("Starting TaskFlow API Server")

    // 连接数据库
    db, err := mysql.NewDatabase(&cfg.Database)
    if err != nil {
        logger.Fatal("Failed to connect to database", logger.Error(err))
    }

    // 设置Gin模式
    if cfg.App.Mode == "production" {
        gin.SetMode(gin.ReleaseMode)
    }

    // 创建Gin引擎
    router := gin.New()
    
    // 添加中间件
    router.Use(gin.Logger())
    router.Use(gin.Recovery())

    // 健康检查端点
    router.GET("/health", func(c *gin.Context) {
        c.JSON(http.StatusOK, gin.H{
            "status": "ok",
            "time":   time.Now().Format(time.RFC3339),
            "app":    cfg.App.Name,
            "version": cfg.App.Version,
        })
    })

    // 创建HTTP服务器
    srv := &http.Server{
        Addr:    fmt.Sprintf(":%d", cfg.App.Port),
        Handler: router,
    }

    // 在goroutine中启动服务器
    go func() {
        logger.Info(fmt.Sprintf("Server starting on port %d", cfg.App.Port))
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            logger.Fatal("Failed to start server", logger.Error(err))
        }
    }()

    // 等待中断信号来优雅地关闭服务器
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit
    logger.Info("Server shutting down...")

    // 设置5秒的超时时间来关闭服务器
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    if err := srv.Shutdown(ctx); err != nil {
        logger.Fatal("Server forced to shutdown", logger.Error(err))
    }

    logger.Info("Server exited")
}
```

### Day 6-7：测试和完善

#### 步骤9：创建Makefile

**Makefile**
```makefile
.PHONY: help build run test clean docker-up docker-down migrate

# 默认目标
help: ## 显示帮助信息
	@echo "Available commands:"
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | sort | awk 'BEGIN {FS = ":.*?## "}; {printf "\033[36m%-20s\033[0m %s\n", $$1, $$2}'

# 构建
build: ## 构建应用程序
	@echo "Building application..."
	@go build -o bin/taskflow cmd/api/main.go

# 运行
run: ## 运行应用程序
	@echo "Running application..."
	@go run cmd/api/main.go

# 测试
test: ## 运行测试
	@echo "Running tests..."
	@go test -v ./...

# 测试覆盖率
test-coverage: ## 运行测试并生成覆盖率报告
	@echo "Running tests with coverage..."
	@go test -v -coverprofile=coverage.out ./...
	@go tool cover -html=coverage.out -o coverage.html
	@echo "Coverage report generated: coverage.html"

# 清理
clean: ## 清理构建文件
	@echo "Cleaning..."
	@rm -rf bin/
	@rm -f coverage.out coverage.html

# Docker开发环境
docker-up: ## 启动Docker开发环境
	@echo "Starting Docker development environment..."
	@docker-compose -f docker-compose.dev.yml up -d

docker-down: ## 停止Docker开发环境
	@echo "Stopping Docker development environment..."
	@docker-compose -f docker-compose.dev.yml down

docker-logs: ## 查看Docker日志
	@docker-compose -f docker-compose.dev.yml logs -f

# 数据库迁移
migrate-up: ## 执行数据库迁移
	@echo "Running database migrations..."
	@go run cmd/migrate/main.go up

migrate-down: ## 回滚数据库迁移
	@echo "Rolling back database migrations..."
	@go run cmd/migrate/main.go down

# 代码格式化
fmt: ## 格式化代码
	@echo "Formatting code..."
	@go fmt ./...

# 代码检查
lint: ## 运行代码检查
	@echo "Running linter..."
	@golangci-lint run

# 生成API文档
docs: ## 生成API文档
	@echo "Generating API documentation..."
	@swag init -g cmd/api/main.go -o docs/swagger

# 安装依赖
deps: ## 安装依赖
	@echo "Installing dependencies..."
	@go mod tidy
	@go mod download
```

#### 步骤10：初始化数据库脚本

**scripts/init.sql**
```sql
-- 创建数据库（如果不存在）
CREATE DATABASE IF NOT EXISTS taskflow CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- 使用数据库
USE taskflow;

-- 创建基础表结构（简化版，用于测试）
CREATE TABLE IF NOT EXISTS users (
    id VARCHAR(36) PRIMARY KEY,
    email VARCHAR(255) UNIQUE NOT NULL,
    name VARCHAR(100) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    avatar VARCHAR(500),
    status ENUM('active', 'inactive', 'suspended') DEFAULT 'active',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_email (email),
    INDEX idx_status (status)
);

-- 插入测试数据
INSERT INTO users (id, email, name, password_hash, status) VALUES 
('user-001', 'admin@taskflow.com', 'Administrator', '$2a$10$example.hash', 'active'),
('user-002', 'user@taskflow.com', 'Test User', '$2a$10$example.hash', 'active')
ON DUPLICATE KEY UPDATE id=id;
```

## 📝 Week 1 总结和下周预告

### 本周完成的工作
- ✅ 项目目录结构搭建
- ✅ 基础配置系统
- ✅ 日志系统
- ✅ 错误处理机制
- ✅ 数据库连接
- ✅ Docker开发环境
- ✅ 基础项目框架

### 验收标准
1. **项目可以启动**：`make run` 能正常启动服务
2. **健康检查**：访问 `http://localhost:8080/health` 返回正常
3. **数据库连接**：启动时日志显示数据库连接成功
4. **Docker环境**：`make docker-up` 能启动完整开发环境

### 下周预告（Week 2）
- 🎯 **JWT认证系统**：用户登录、token生成和验证
- 🎯 **基础中间件**：认证、CORS、日志、错误处理
- 🎯 **用户模型**：User聚合根和基础操作
- 🎯 **API框架**：统一的请求响应格式
- 🎯 **Swagger文档**：API文档自动生成

### 🏃‍♂️ 现在开始实践

请按照上面的步骤创建项目结构，我会在每一步为你提供详细指导。如果遇到任何问题，随时告诉我！

**第一步**：创建项目目录结构并初始化Go模块
**第二步**：创建配置文件和Docker环境
**第三步**：实现基础工具类（配置、日志、错误处理）
**第四步**：创建主程序并测试运行

准备好开始了吗？🚀
