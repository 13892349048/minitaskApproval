# å¤šå±‚çº§é¡¹ç›®ç®¡ç†ç³»ç»Ÿ DDD è®¾è®¡

## ğŸ—ï¸ ä¸šåŠ¡åœºæ™¯åˆ†æ

### ç»„ç»‡ç»“æ„å±‚çº§
```
å¤§é¢†å¯¼ (Director)
â”œâ”€â”€ å¤§é¡¹ç›® (Master Project)
â”‚   â”œâ”€â”€ å°é¡¹ç›®A (Sub Project A) â†’ é¡¹ç›®é¢†å¯¼A (Project Leader A)
â”‚   â”‚   â”œâ”€â”€ ä»»åŠ¡1 (Task 1) â†’ å‘˜å·¥X
â”‚   â”‚   â””â”€â”€ ä»»åŠ¡2 (Task 2) â†’ å‘˜å·¥Y
â”‚   â”œâ”€â”€ å°é¡¹ç›®B (Sub Project B) â†’ é¡¹ç›®é¢†å¯¼B (Project Leader B)
â”‚   â”‚   â”œâ”€â”€ ä»»åŠ¡3 (Task 3) â†’ å‘˜å·¥Z
â”‚   â”‚   â””â”€â”€ ä»»åŠ¡4 (Task 4) â†’ å‘˜å·¥W
â”‚   â””â”€â”€ ä¸´æ—¶ä»»åŠ¡ (Temporary Tasks) â†’ ç›´æ¥ç”±å¤§é¢†å¯¼ç®¡ç†
â”‚       â”œâ”€â”€ ä»»åŠ¡5 (Task 5) â†’ å‘˜å·¥V
â”‚       â””â”€â”€ ä»»åŠ¡6 (Task 6) â†’ é¡¹ç›®é¢†å¯¼A
```

### æƒé™çŸ©é˜µè®¾è®¡

| è§’è‰² | äººå‘˜ç®¡ç† | é¡¹ç›®åˆ›å»º/åˆ†é… | ä»»åŠ¡åˆ›å»º | ä»»åŠ¡åˆ†é… | ä»»åŠ¡å®¡æ‰¹ | ä»»åŠ¡æ‰§è¡Œ |
|------|----------|---------------|----------|----------|----------|----------|
| **å¤§é¢†å¯¼** | âœ… æ‰€æœ‰äººå‘˜ | âœ… åˆ›å»ºé¡¹ç›®å¹¶åˆ†é…ç»™é¡¹ç›®é¢†å¯¼ | âœ… åˆ›å»ºä¸´æ—¶ä»»åŠ¡ | âœ… åˆ†é…ä»»ä½•ä»»åŠ¡ | âœ… å®¡æ‰¹æ‰€æœ‰ä»»åŠ¡ | âŒ ä¸æ‰§è¡Œä»»åŠ¡ |
| **é¡¹ç›®é¢†å¯¼** | âŒ æ— äººå‘˜ç®¡ç†æƒé™ | âŒ ä¸èƒ½åˆ›å»ºé¡¹ç›® | âœ… åˆ›å»ºæ‰€ç®¡ç†é¡¹ç›®å†…ä»»åŠ¡ | âœ… åˆ†é…é¡¹ç›®å†…ä»»åŠ¡ç»™å‘˜å·¥ | âœ… å®¡æ‰¹é¡¹ç›®å†…ä»»åŠ¡ | âœ… æ‰§è¡Œä»»åŠ¡ |
| **å‘˜å·¥** | âŒ æ— äººå‘˜ç®¡ç†æƒé™ | âŒ ä¸èƒ½åˆ›å»ºé¡¹ç›® | âœ… ç”³è¯·ä»»åŠ¡ | âŒ ä¸èƒ½åˆ†é…ä»»åŠ¡ | âŒ ä¸èƒ½å®¡æ‰¹ä»»åŠ¡ | âœ… æ‰§è¡Œè¢«åˆ†é…çš„ä»»åŠ¡ |

## ğŸ¯ é¢†åŸŸæ¨¡å‹é‡æ–°è®¾è®¡

### é™ç•Œä¸Šä¸‹æ–‡åˆ’åˆ†

```mermaid
graph TB
    subgraph "é¡¹ç›®ç®¡ç†ä¸Šä¸‹æ–‡"
        Project[é¡¹ç›®èšåˆ]
        ProjectHierarchy[é¡¹ç›®å±‚çº§]
        ProjectAssignment[é¡¹ç›®åˆ†é…]
    end
    
    subgraph "ä»»åŠ¡ç®¡ç†ä¸Šä¸‹æ–‡"
        Task[ä»»åŠ¡èšåˆ]
        TaskAssignment[ä»»åŠ¡åˆ†é…]
        TaskStatus[ä»»åŠ¡çŠ¶æ€]
    end
    
    subgraph "äººå‘˜ç®¡ç†ä¸Šä¸‹æ–‡"
        User[ç”¨æˆ·èšåˆ]
        Role[è§’è‰²ç®¡ç†]
        Permission[æƒé™ç®¡ç†]
        OrganizationStructure[ç»„ç»‡ç»“æ„]
    end
    
    subgraph "æƒé™æ§åˆ¶ä¸Šä¸‹æ–‡"
        AccessControl[è®¿é—®æ§åˆ¶]
        PermissionRule[æƒé™è§„åˆ™]
        RoleBasedAccess[åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶]
    end
    
    Project --> Task : åŒ…å«
    User --> Project : ç®¡ç†
    User --> Task : æ‰§è¡Œ/å®¡æ‰¹
    AccessControl --> User : æ§åˆ¶
    AccessControl --> Project : æ§åˆ¶
    AccessControl --> Task : æ§åˆ¶
```

### æ ¸å¿ƒèšåˆæ ¹è®¾è®¡

#### 1. Project é¡¹ç›®èšåˆæ ¹
```go
// é¡¹ç›®èšåˆæ ¹
type Project struct {
    ID          ProjectID
    Name        string
    Description string
    ProjectType ProjectType    // MASTER_PROJECT, SUB_PROJECT, TEMPORARY_SCOPE
    
    // å±‚çº§å…³ç³»
    ParentProjectID *ProjectID  // çˆ¶é¡¹ç›®IDï¼Œé¡¶çº§é¡¹ç›®ä¸ºnil
    ChildProjects   []ProjectID // å­é¡¹ç›®IDåˆ—è¡¨
    
    // ç®¡ç†äººå‘˜
    OwnerID         UserID      // é¡¹ç›®æ‰€æœ‰è€…ï¼ˆå¤§é¢†å¯¼ï¼‰
    ManagerID       *UserID     // é¡¹ç›®ç®¡ç†è€…ï¼ˆé¡¹ç›®é¢†å¯¼ï¼Œå¯èƒ½ä¸ºç©ºï¼‰
    
    // é¡¹ç›®çŠ¶æ€
    Status          ProjectStatus
    StartDate       time.Time
    EndDate         *time.Time
    
    // é¡¹ç›®æˆå‘˜
    Members         []ProjectMember
    
    // é¢†åŸŸäº‹ä»¶
    events          []DomainEvent
}

// é¡¹ç›®ç±»å‹
type ProjectType int
const (
    ProjectTypeMaster ProjectType = iota    // å¤§é¡¹ç›®
    ProjectTypeSub                          // å°é¡¹ç›®
    ProjectTypeTemporary                    // ä¸´æ—¶ä»»åŠ¡åŸŸï¼ˆç”¨äºç®¡ç†ä¸å±äºå°é¡¹ç›®çš„ä»»åŠ¡ï¼‰
)

// é¡¹ç›®æˆå‘˜
type ProjectMember struct {
    UserID      UserID
    Role        ProjectRole     // PROJECT_MANAGER, MEMBER
    JoinedAt    time.Time
    Permissions []Permission
}

// é¡¹ç›®è§’è‰²
type ProjectRole int
const (
    ProjectRoleManager ProjectRole = iota   // é¡¹ç›®ç®¡ç†è€…
    ProjectRoleMember                       // é¡¹ç›®æˆå‘˜
)

// é¡¹ç›®ä¸šåŠ¡æ–¹æ³•
func (p *Project) AssignManager(manager *User, assigner *User) error {
    // åªæœ‰é¡¹ç›®æ‰€æœ‰è€…å¯ä»¥åˆ†é…é¡¹ç›®ç®¡ç†è€…
    if p.OwnerID != assigner.ID {
        return errors.New("only project owner can assign manager")
    }
    
    // æ£€æŸ¥è¢«åˆ†é…è€…æ˜¯å¦æœ‰é¡¹ç›®ç®¡ç†æƒé™
    if !manager.HasRole(RoleProjectLeader) {
        return errors.New("user does not have project leader role")
    }
    
    p.ManagerID = &manager.ID
    
    // æ·»åŠ åˆ°é¡¹ç›®æˆå‘˜
    member := ProjectMember{
        UserID:   manager.ID,
        Role:     ProjectRoleManager,
        JoinedAt: time.Now(),
        Permissions: []Permission{
            PermissionCreateTask,
            PermissionAssignTask,
            PermissionApproveTask,
        },
    }
    p.Members = append(p.Members, member)
    
    p.AddEvent(&ProjectManagerAssignedEvent{
        ProjectID:  p.ID,
        ManagerID:  manager.ID,
        AssignerID: assigner.ID,
        Timestamp:  time.Now(),
    })
    
    return nil
}

func (p *Project) AddMember(user *User, adder *User) error {
    // æ£€æŸ¥æ·»åŠ è€…æƒé™
    if !p.CanManageMembers(adder) {
        return errors.New("insufficient permission to add members")
    }
    
    member := ProjectMember{
        UserID:   user.ID,
        Role:     ProjectRoleMember,
        JoinedAt: time.Now(),
        Permissions: []Permission{
            PermissionExecuteTask,
        },
    }
    p.Members = append(p.Members, member)
    
    return nil
}

func (p *Project) CanManageMembers(user *User) bool {
    // é¡¹ç›®æ‰€æœ‰è€…å¯ä»¥ç®¡ç†æˆå‘˜
    if p.OwnerID == user.ID {
        return true
    }
    
    // é¡¹ç›®ç®¡ç†è€…å¯ä»¥ç®¡ç†æˆå‘˜
    if p.ManagerID != nil && *p.ManagerID == user.ID {
        return true
    }
    
    return false
}

func (p *Project) GetProjectHierarchy() *ProjectHierarchy {
    return &ProjectHierarchy{
        RootProjectID: p.GetRootProjectID(),
        Levels:        p.calculateHierarchyLevels(),
    }
}
```

#### 2. Task ä»»åŠ¡èšåˆæ ¹ï¼ˆå¢å¼ºç‰ˆï¼‰
```go
// ä»»åŠ¡èšåˆæ ¹ï¼ˆå¢å¼ºç‰ˆï¼‰
type Task struct {
    ID          TaskID
    Title       string
    Description string
    TaskType    TaskType
    Priority    Priority
    
    // é¡¹ç›®å½’å±
    ProjectID   ProjectID       // æ‰€å±é¡¹ç›®ID
    
    // çŠ¶æ€ä¿¡æ¯
    Status      TaskStatus
    
    // å‚ä¸äººå‘˜
    CreatorID   UserID          // ä»»åŠ¡åˆ›å»ºè€…
    AssignerID  UserID          // ä»»åŠ¡åˆ†é…è€…
    ApproverID  UserID          // å®¡æ‰¹äºº
    ExecutorID  UserID          // æ‰§è¡Œäºº
    ReviewerID  *UserID         // éªŒæ”¶äºº
    
    // æ—¶é—´ä¿¡æ¯
    CreatedAt     time.Time
    AssignedAt    *time.Time
    ApprovedAt    *time.Time
    StartedAt     *time.Time
    SubmittedAt   *time.Time
    CompletedAt   *time.Time
    DueDate       *time.Time
    
    // å®¡æ‰¹è®°å½•
    ApprovalRecords   []Approval
    
    // åˆ†é…å†å²
    AssignmentHistory []Assignment
    
    events []DomainEvent
}

// ä»»åŠ¡ä¸šåŠ¡æ–¹æ³•ï¼ˆè€ƒè™‘é¡¹ç›®æƒé™ï¼‰
func (t *Task) AssignToUser(assigner *User, executor *User, project *Project) error {
    // æ£€æŸ¥åˆ†é…è€…æƒé™
    if !t.CanAssignTask(assigner, project) {
        return errors.New("insufficient permission to assign task")
    }
    
    // æ£€æŸ¥æ‰§è¡Œè€…æ˜¯å¦æ˜¯é¡¹ç›®æˆå‘˜
    if !project.IsMember(executor.ID) {
        return errors.New("executor is not a project member")
    }
    
    t.AssignerID = assigner.ID
    t.ExecutorID = executor.ID
    t.Status = TaskStatusAssigned
    now := time.Now()
    t.AssignedAt = &now
    
    // è®°å½•åˆ†é…å†å²
    assignment := Assignment{
        FromUserID:  nil,
        ToUserID:    executor.ID,
        AssignerID:  assigner.ID,
        Reason:      "initial assignment",
        AssignedAt:  now,
    }
    t.AssignmentHistory = append(t.AssignmentHistory, assignment)
    
    t.AddEvent(&TaskAssignedEvent{
        TaskID:     t.ID,
        ProjectID:  t.ProjectID,
        ExecutorID: executor.ID,
        AssignerID: assigner.ID,
        Timestamp:  now,
    })
    
    return nil
}

func (t *Task) CanAssignTask(user *User, project *Project) bool {
    // é¡¹ç›®æ‰€æœ‰è€…å¯ä»¥åˆ†é…ä»»ä½•é¡¹ç›®å†…çš„ä»»åŠ¡
    if project.OwnerID == user.ID {
        return true
    }
    
    // é¡¹ç›®ç®¡ç†è€…å¯ä»¥åˆ†é…æ‰€ç®¡ç†é¡¹ç›®å†…çš„ä»»åŠ¡
    if project.ManagerID != nil && *project.ManagerID == user.ID {
        return true
    }
    
    return false
}

func (t *Task) CanApproveTask(user *User, project *Project) bool {
    // é¡¹ç›®æ‰€æœ‰è€…å¯ä»¥å®¡æ‰¹ä»»ä½•é¡¹ç›®å†…çš„ä»»åŠ¡
    if project.OwnerID == user.ID {
        return true
    }
    
    // é¡¹ç›®ç®¡ç†è€…å¯ä»¥å®¡æ‰¹æ‰€ç®¡ç†é¡¹ç›®å†…çš„ä»»åŠ¡
    if project.ManagerID != nil && *project.ManagerID == user.ID {
        return true
    }
    
    return false
}
```

#### 3. User ç”¨æˆ·èšåˆæ ¹ï¼ˆå¢å¼ºç‰ˆï¼‰
```go
// ç”¨æˆ·èšåˆæ ¹ï¼ˆå¢å¼ºç‰ˆï¼‰
type User struct {
    ID          UserID
    Name        string
    Email       string
    
    // è§’è‰²å’Œæƒé™
    Roles       []Role
    Permissions []Permission
    
    // ç»„ç»‡ç»“æ„
    DepartmentID    DepartmentID
    ManagerID       *UserID         // ç›´å±ä¸Šçº§
    Subordinates    []UserID        // ä¸‹å±åˆ—è¡¨
    
    // é¡¹ç›®å…³è”
    OwnedProjects   []ProjectID     // æ‹¥æœ‰çš„é¡¹ç›®ï¼ˆå¤§é¢†å¯¼ï¼‰
    ManagedProjects []ProjectID     // ç®¡ç†çš„é¡¹ç›®ï¼ˆé¡¹ç›®é¢†å¯¼ï¼‰
    MemberProjects  []ProjectID     // å‚ä¸çš„é¡¹ç›®ï¼ˆé¡¹ç›®æˆå‘˜ï¼‰
    
    events []DomainEvent
}

// ç”¨æˆ·è§’è‰²
type Role int
const (
    RoleDirector Role = iota        // å¤§é¢†å¯¼
    RoleProjectLeader               // é¡¹ç›®é¢†å¯¼
    RoleEmployee                    // å‘˜å·¥
)

// æƒé™æšä¸¾
type Permission int
const (
    // äººå‘˜ç®¡ç†æƒé™
    PermissionManageUsers Permission = iota
    PermissionAssignProjectManager
    
    // é¡¹ç›®ç®¡ç†æƒé™
    PermissionCreateProject
    PermissionAssignProject
    PermissionManageProject
    
    // ä»»åŠ¡ç®¡ç†æƒé™
    PermissionCreateTask
    PermissionAssignTask
    PermissionApproveTask
    PermissionExecuteTask
    PermissionReviewTask
)

// ç”¨æˆ·ä¸šåŠ¡æ–¹æ³•
func (u *User) CanManageUser(targetUser *User) bool {
    // æ£€æŸ¥æ˜¯å¦æœ‰äººå‘˜ç®¡ç†æƒé™
    if !u.HasPermission(PermissionManageUsers) {
        return false
    }
    
    // æ£€æŸ¥æ˜¯å¦æ˜¯ç›®æ ‡ç”¨æˆ·çš„ä¸Šçº§
    return u.IsManagerOf(targetUser.ID)
}

func (u *User) CanCreateProject() bool {
    return u.HasRole(RoleDirector) && u.HasPermission(PermissionCreateProject)
}

func (u *User) CanAssignProject(project *Project) bool {
    // åªæœ‰é¡¹ç›®æ‰€æœ‰è€…å¯ä»¥åˆ†é…é¡¹ç›®
    return project.OwnerID == u.ID && u.HasPermission(PermissionAssignProject)
}

func (u *User) HasRole(role Role) bool {
    for _, r := range u.Roles {
        if r == role {
            return true
        }
    }
    return false
}

func (u *User) HasPermission(permission Permission) bool {
    for _, p := range u.Permissions {
        if p == permission {
            return true
        }
    }
    return false
}

func (u *User) IsManagerOf(userID UserID) bool {
    for _, subordinateID := range u.Subordinates {
        if subordinateID == userID {
            return true
        }
    }
    return false
}
```

### é¢†åŸŸæœåŠ¡è®¾è®¡

#### 1. é¡¹ç›®æƒé™æœåŠ¡
```go
type ProjectPermissionService struct {
    userRepo    UserRepository
    projectRepo ProjectRepository
}

func (s *ProjectPermissionService) CanUserAccessProject(userID UserID, projectID ProjectID) (bool, error) {
    user, err := s.userRepo.FindByID(userID)
    if err != nil {
        return false, err
    }
    
    project, err := s.projectRepo.FindByID(projectID)
    if err != nil {
        return false, err
    }
    
    // é¡¹ç›®æ‰€æœ‰è€…å¯ä»¥è®¿é—®
    if project.OwnerID == userID {
        return true, nil
    }
    
    // é¡¹ç›®ç®¡ç†è€…å¯ä»¥è®¿é—®
    if project.ManagerID != nil && *project.ManagerID == userID {
        return true, nil
    }
    
    // é¡¹ç›®æˆå‘˜å¯ä»¥è®¿é—®
    if project.IsMember(userID) {
        return true, nil
    }
    
    return false, nil
}

func (s *ProjectPermissionService) CanUserManageTask(userID UserID, taskID TaskID) (bool, error) {
    // è·å–ä»»åŠ¡å’Œæ‰€å±é¡¹ç›®
    task, err := s.taskRepo.FindByID(taskID)
    if err != nil {
        return false, err
    }
    
    project, err := s.projectRepo.FindByID(task.ProjectID)
    if err != nil {
        return false, err
    }
    
    return task.CanAssignTask(user, project), nil
}
```

#### 2. ä»»åŠ¡åˆ†é…æœåŠ¡
```go
type TaskAssignmentService struct {
    userRepo           UserRepository
    projectRepo        ProjectRepository
    taskRepo           TaskRepository
    permissionService  ProjectPermissionService
}

func (s *TaskAssignmentService) AssignTaskWithinProject(
    assignerID UserID,
    taskID TaskID,
    executorID UserID,
) error {
    // è·å–ç›¸å…³å¯¹è±¡
    assigner, err := s.userRepo.FindByID(assignerID)
    if err != nil {
        return err
    }
    
    executor, err := s.userRepo.FindByID(executorID)
    if err != nil {
        return err
    }
    
    task, err := s.taskRepo.FindByID(taskID)
    if err != nil {
        return err
    }
    
    project, err := s.projectRepo.FindByID(task.ProjectID)
    if err != nil {
        return err
    }
    
    // æ‰§è¡Œåˆ†é…
    return task.AssignToUser(assigner, executor, project)
}

func (s *TaskAssignmentService) AutoAssignTaskBasedOnWorkload(
    taskID TaskID,
    projectID ProjectID,
) (*User, error) {
    // è·å–é¡¹ç›®æˆå‘˜
    project, err := s.projectRepo.FindByID(projectID)
    if err != nil {
        return nil, err
    }
    
    // è·å–æ‰€æœ‰é¡¹ç›®æˆå‘˜çš„å·¥ä½œè´Ÿè½½
    members := project.GetActiveMembers()
    var bestCandidate *User
    minWorkload := math.MaxInt32
    
    for _, member := range members {
        user, err := s.userRepo.FindByID(member.UserID)
        if err != nil {
            continue
        }
        
        // è®¡ç®—ç”¨æˆ·å½“å‰å·¥ä½œè´Ÿè½½
        workload, err := s.calculateUserWorkload(user.ID)
        if err != nil {
            continue
        }
        
        if workload < minWorkload {
            minWorkload = workload
            bestCandidate = user
        }
    }
    
    return bestCandidate, nil
}
```

### åº”ç”¨æœåŠ¡å±‚è®¾è®¡

#### é¡¹ç›®ç®¡ç†åº”ç”¨æœåŠ¡
```go
type ProjectAppService struct {
    projectRepo       ProjectRepository
    userRepo          UserRepository
    taskRepo          TaskRepository
    permissionService ProjectPermissionService
    eventPublisher    EventPublisher
}

// åˆ›å»ºä¸»é¡¹ç›®ï¼ˆåªæœ‰å¤§é¢†å¯¼å¯ä»¥ï¼‰
func (s *ProjectAppService) CreateMasterProject(cmd *CreateMasterProjectCommand) (*ProjectDTO, error) {
    // éªŒè¯ç”¨æˆ·æƒé™
    creator, err := s.userRepo.FindByID(cmd.CreatorID)
    if err != nil {
        return nil, err
    }
    
    if !creator.CanCreateProject() {
        return nil, errors.New("insufficient permission to create project")
    }
    
    // åˆ›å»ºä¸»é¡¹ç›®
    project := NewProject(
        cmd.Name,
        cmd.Description,
        ProjectTypeMaster,
        creator.ID,
        nil, // ä¸»é¡¹ç›®æ²¡æœ‰çˆ¶é¡¹ç›®
    )
    
    // ä¿å­˜é¡¹ç›®
    if err := s.projectRepo.Save(project); err != nil {
        return nil, err
    }
    
    // å‘å¸ƒäº‹ä»¶
    for _, event := range project.GetEvents() {
        s.eventPublisher.Publish(event)
    }
    
    return ProjectToDTO(project), nil
}

// åˆ›å»ºå­é¡¹ç›®
func (s *ProjectAppService) CreateSubProject(cmd *CreateSubProjectCommand) (*ProjectDTO, error) {
    // è·å–çˆ¶é¡¹ç›®
    parentProject, err := s.projectRepo.FindByID(cmd.ParentProjectID)
    if err != nil {
        return nil, err
    }
    
    // éªŒè¯åˆ›å»ºè€…æƒé™ï¼ˆåªæœ‰çˆ¶é¡¹ç›®æ‰€æœ‰è€…å¯ä»¥åˆ›å»ºå­é¡¹ç›®ï¼‰
    creator, err := s.userRepo.FindByID(cmd.CreatorID)
    if err != nil {
        return nil, err
    }
    
    if parentProject.OwnerID != creator.ID {
        return nil, errors.New("only parent project owner can create sub project")
    }
    
    // åˆ›å»ºå­é¡¹ç›®
    subProject := NewProject(
        cmd.Name,
        cmd.Description,
        ProjectTypeSub,
        creator.ID,
        &cmd.ParentProjectID,
    )
    
    // ä¿å­˜é¡¹ç›®
    if err := s.projectRepo.Save(subProject); err != nil {
        return nil, err
    }
    
    // æ›´æ–°çˆ¶é¡¹ç›®çš„å­é¡¹ç›®åˆ—è¡¨
    parentProject.AddChildProject(subProject.ID)
    if err := s.projectRepo.Save(parentProject); err != nil {
        return nil, err
    }
    
    return ProjectToDTO(subProject), nil
}

// åˆ†é…é¡¹ç›®ç®¡ç†è€…
func (s *ProjectAppService) AssignProjectManager(cmd *AssignProjectManagerCommand) error {
    // è·å–é¡¹ç›®å’Œç›¸å…³ç”¨æˆ·
    project, err := s.projectRepo.FindByID(cmd.ProjectID)
    if err != nil {
        return err
    }
    
    manager, err := s.userRepo.FindByID(cmd.ManagerID)
    if err != nil {
        return err
    }
    
    assigner, err := s.userRepo.FindByID(cmd.AssignerID)
    if err != nil {
        return err
    }
    
    // åˆ†é…ç®¡ç†è€…
    if err := project.AssignManager(manager, assigner); err != nil {
        return err
    }
    
    // æ›´æ–°ç”¨æˆ·çš„ç®¡ç†é¡¹ç›®åˆ—è¡¨
    manager.AddManagedProject(project.ID)
    
    // ä¿å­˜æ›´æ”¹
    if err := s.projectRepo.Save(project); err != nil {
        return err
    }
    
    if err := s.userRepo.Save(manager); err != nil {
        return err
    }
    
    // å‘å¸ƒäº‹ä»¶
    for _, event := range project.GetEvents() {
        s.eventPublisher.Publish(event)
    }
    
    return nil
}
```

#### ä»»åŠ¡ç®¡ç†åº”ç”¨æœåŠ¡ï¼ˆå¢å¼ºç‰ˆï¼‰
```go
type TaskAppService struct {
    taskRepo           TaskRepository
    projectRepo        ProjectRepository
    userRepo           UserRepository
    assignmentService  TaskAssignmentService
    permissionService  ProjectPermissionService
    eventPublisher     EventPublisher
}

// åœ¨é¡¹ç›®å†…åˆ›å»ºä»»åŠ¡
func (s *TaskAppService) CreateTaskInProject(cmd *CreateTaskInProjectCommand) (*TaskDTO, error) {
    // è·å–é¡¹ç›®å’Œåˆ›å»ºè€…
    project, err := s.projectRepo.FindByID(cmd.ProjectID)
    if err != nil {
        return nil, err
    }
    
    creator, err := s.userRepo.FindByID(cmd.CreatorID)
    if err != nil {
        return nil, err
    }
    
    // æ£€æŸ¥åˆ›å»ºè€…æƒé™
    canAccess, err := s.permissionService.CanUserAccessProject(creator.ID, project.ID)
    if err != nil {
        return nil, err
    }
    if !canAccess {
        return nil, errors.New("insufficient permission to create task in this project")
    }
    
    // åˆ›å»ºä»»åŠ¡
    task := NewTask(
        cmd.Title,
        cmd.Description,
        cmd.TaskType,
        cmd.Priority,
        project.ID,
        creator.ID,
    )
    
    // ä¿å­˜ä»»åŠ¡
    if err := s.taskRepo.Save(task); err != nil {
        return nil, err
    }
    
    return TaskToDTO(task), nil
}

// è·¨é¡¹ç›®åˆ†é…ä»»åŠ¡ï¼ˆåªæœ‰å¤§é¢†å¯¼å¯ä»¥ï¼‰
func (s *TaskAppService) AssignTaskAcrossProjects(cmd *AssignTaskAcrossProjectsCommand) error {
    // éªŒè¯åˆ†é…è€…æƒé™ï¼ˆåªæœ‰å¤§é¢†å¯¼å¯ä»¥è·¨é¡¹ç›®åˆ†é…ï¼‰
    assigner, err := s.userRepo.FindByID(cmd.AssignerID)
    if err != nil {
        return err
    }
    
    if !assigner.HasRole(RoleDirector) {
        return errors.New("only director can assign tasks across projects")
    }
    
    // æ‰§è¡Œåˆ†é…
    return s.assignmentService.AssignTaskWithinProject(
        cmd.AssignerID,
        cmd.TaskID,
        cmd.ExecutorID,
    )
}
```

## ğŸ”„ å¤æ‚ä¸šåŠ¡æµç¨‹è®¾è®¡

### 1. é¡¹ç›®åˆ›å»ºå’Œåˆ†é…æµç¨‹
```mermaid
sequenceDiagram
    participant Director as å¤§é¢†å¯¼
    participant System as ç³»ç»Ÿ
    participant ProjectLeader as é¡¹ç›®é¢†å¯¼
    participant Employee as å‘˜å·¥
    
    Director->>System: åˆ›å»ºå¤§é¡¹ç›®
    System->>System: éªŒè¯æƒé™(Directorè§’è‰²)
    System->>Director: é¡¹ç›®åˆ›å»ºæˆåŠŸ
    
    Director->>System: åˆ›å»ºå­é¡¹ç›®A
    Director->>System: åˆ†é…é¡¹ç›®é¢†å¯¼Aç®¡ç†å­é¡¹ç›®A
    System->>ProjectLeader: é€šçŸ¥è¢«åˆ†é…ç®¡ç†å­é¡¹ç›®A
    
    ProjectLeader->>System: åœ¨å­é¡¹ç›®Aä¸­åˆ›å»ºä»»åŠ¡
    System->>System: éªŒè¯é¡¹ç›®ç®¡ç†æƒé™
    ProjectLeader->>System: åˆ†é…ä»»åŠ¡ç»™å‘˜å·¥
    System->>Employee: é€šçŸ¥è¢«åˆ†é…ä»»åŠ¡
```

### 2. ä¸´æ—¶ä»»åŠ¡å¤„ç†æµç¨‹
```mermaid
sequenceDiagram
    participant Director as å¤§é¢†å¯¼
    participant System as ç³»ç»Ÿ
    participant Employee as å‘˜å·¥
    participant ProjectLeader as é¡¹ç›®é¢†å¯¼
    
    Director->>System: åˆ›å»ºä¸´æ—¶ä»»åŠ¡(ä¸å±äºä»»ä½•å­é¡¹ç›®)
    Director->>System: ç›´æ¥åˆ†é…ç»™å‘˜å·¥æˆ–é¡¹ç›®é¢†å¯¼
    
    alt åˆ†é…ç»™å‘˜å·¥
        System->>Employee: é€šçŸ¥ä»»åŠ¡åˆ†é…
        Employee->>System: æ‰§è¡Œä»»åŠ¡
        Employee->>System: æäº¤å®Œæˆ
        System->>Director: é€šçŸ¥éªŒæ”¶
    else åˆ†é…ç»™é¡¹ç›®é¢†å¯¼
        System->>ProjectLeader: é€šçŸ¥ä»»åŠ¡åˆ†é…
        ProjectLeader->>System: æ‰§è¡Œä»»åŠ¡
        ProjectLeader->>System: æäº¤å®Œæˆ
        System->>Director: é€šçŸ¥éªŒæ”¶
    end
```

## ğŸ“Š æƒé™æ§åˆ¶å®ç°

### RBAC + ABAC æ··åˆæƒé™æ¨¡å‹
```go
// æƒé™æ£€æŸ¥æœåŠ¡
type PermissionCheckService struct {
    userRepo    UserRepository
    projectRepo ProjectRepository
    taskRepo    TaskRepository
}

// æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å¯ä»¥æ‰§è¡Œç‰¹å®šæ“ä½œ
func (s *PermissionCheckService) CanUserPerformAction(
    userID UserID,
    action string,
    resourceType string,
    resourceID string,
    context map[string]interface{},
) (bool, error) {
    user, err := s.userRepo.FindByID(userID)
    if err != nil {
        return false, err
    }
    
    switch resourceType {
    case "project":
        return s.checkProjectPermission(user, action, ProjectID(resourceID), context)
    case "task":
        return s.checkTaskPermission(user, action, TaskID(resourceID), context)
    case "user":
        return s.checkUserPermission(user, action, UserID(resourceID), context)
    default:
        return false, errors.New("unknown resource type")
    }
}

func (s *PermissionCheckService) checkProjectPermission(
    user *User,
    action string,
    projectID ProjectID,
    context map[string]interface{},
) (bool, error) {
    project, err := s.projectRepo.FindByID(projectID)
    if err != nil {
        return false, err
    }
    
    switch action {
    case "create_sub_project":
        return project.OwnerID == user.ID && user.HasRole(RoleDirector), nil
    case "assign_manager":
        return project.OwnerID == user.ID, nil
    case "manage_members":
        return project.CanManageMembers(user), nil
    case "create_task":
        return project.OwnerID == user.ID || 
               (project.ManagerID != nil && *project.ManagerID == user.ID), nil
    default:
        return false, nil
    }
}

func (s *PermissionCheckService) checkTaskPermission(
    user *User,
    action string,
    taskID TaskID,
    context map[string]interface{},
) (bool, error) {
    task, err := s.taskRepo.FindByID(taskID)
    if err != nil {
        return false, err
    }
    
    project, err := s.projectRepo.FindByID(task.ProjectID)
    if err != nil {
        return false, err
    }
    
    switch action {
    case "assign_task":
        return task.CanAssignTask(user, project), nil
    case "approve_task":
        return task.CanApproveTask(user, project), nil
    case "execute_task":
        return task.ExecutorID == user.ID, nil
    default:
        return false, nil
    }
}
```

## ğŸ¯ è®¾è®¡ä¼˜åŠ¿å’Œå¯ä¿¡åº¦è¯„åˆ†

### è®¾è®¡ä¼˜åŠ¿
1. **å±‚çº§æ¸…æ™°**ï¼šæ”¯æŒå¤šå±‚çº§é¡¹ç›®ç®¡ç†å’Œäººå‘˜ç®¡ç†
2. **æƒé™ç²¾ç»†**ï¼šåŸºäºè§’è‰²å’Œé¡¹ç›®å½’å±çš„ç»†ç²’åº¦æƒé™æ§åˆ¶
3. **ä¸šåŠ¡å®Œæ•´**ï¼šè¦†ç›–äº†é¡¹ç›®åˆ›å»ºã€åˆ†é…ã€ä»»åŠ¡ç®¡ç†çš„å®Œæ•´æµç¨‹
4. **æ‰©å±•æ€§å¼º**ï¼šæ”¯æŒæ›´å¤æ‚çš„ç»„ç»‡ç»“æ„å’Œé¡¹ç›®å±‚çº§
5. **DDDè§„èŒƒ**ï¼šä¸¥æ ¼éµå¾ªDDDçš„èšåˆæ ¹ã€é¢†åŸŸæœåŠ¡ã€åº”ç”¨æœåŠ¡è®¾è®¡

### å¯ä¿¡åº¦è¯„åˆ†

| è¯„ä¼°ç»´åº¦ | å¾—åˆ† | è¯´æ˜ |
|----------|------|------|
| **ä¸šåŠ¡å¤æ‚åº¦è¦†ç›–** | 9.5/10 | âœ… å®Œæ•´è¦†ç›–å¤šå±‚çº§é¡¹ç›®ç®¡ç†åœºæ™¯ |
| **æƒé™æ¨¡å‹è®¾è®¡** | 9.0/10 | âœ… RBAC+ABACæ··åˆæ¨¡å‹ï¼Œæƒé™ç²¾ç»†åŒ– |
| **DDDå®ç°è´¨é‡** | 9.0/10 | âœ… èšåˆæ ¹è®¾è®¡åˆç†ï¼Œè¾¹ç•Œæ¸…æ™° |
| **ä»£ç å¯å®ç°æ€§** | 8.5/10 | âœ… æä¾›å®Œæ•´çš„Goä»£ç å®ç°æ¡†æ¶ |
| **æ‰©å±•æ€§** | 9.0/10 | âœ… æ”¯æŒæ›´å¤æ‚çš„ä¼ä¸šç»„ç»‡ç»“æ„ |
| **å­¦ä¹ ä»·å€¼** | 9.5/10 | âœ… æ¶µç›–å¤æ‚ä¸šåŠ¡å»ºæ¨¡å’Œæƒé™è®¾è®¡ |

**ğŸ† æ€»ä½“å¯ä¿¡åº¦ï¼š9.1/10**

è¿™ä¸ªè®¾è®¡å®Œå…¨è§£å†³äº†ä½ æå‡ºçš„å¤æ‚ä¸šåŠ¡åœºæ™¯ï¼ŒåŒ…æ‹¬å¤šå±‚çº§é¡¹ç›®ç®¡ç†ã€ç²¾ç»†åŒ–æƒé™æ§åˆ¶ã€ä¸´æ—¶ä»»åŠ¡å¤„ç†ç­‰é—®é¢˜ã€‚å®ƒä¸ä»…æ˜¯ä¸€ä¸ªå­¦ä¹ DDDçš„å¥½æ¡ˆä¾‹ï¼Œä¹Ÿæ˜¯ä¸€ä¸ªå¯ä»¥ç›´æ¥åº”ç”¨äºä¼ä¸šçš„é¡¹ç›®ç®¡ç†ç³»ç»Ÿè®¾è®¡ã€‚
