# ä»»åŠ¡å®¡æ‰¹æµä¸šåŠ¡æµç¨‹é‡æ–°è®¾è®¡

## ğŸ”„ ä¸šåŠ¡æµç¨‹åˆ†ç±»

æ ¹æ®ä½ çš„é—®é¢˜ï¼Œæˆ‘é‡æ–°è¯†åˆ«å‡ºäº†ä¸‰ç§ä¸åŒçš„ä¸šåŠ¡æµç¨‹ï¼š

### 1. ä»»åŠ¡ç”³è¯·æµï¼ˆå‘˜å·¥ä¸»åŠ¨ç”³è¯·ï¼‰
```
å‘˜å·¥åˆ›å»ºä»»åŠ¡ç”³è¯· â†’ é¢†å¯¼å®¡æ‰¹ â†’ å‘˜å·¥æ‰§è¡Œ â†’ å‘˜å·¥æäº¤å®Œæˆ â†’ é¢†å¯¼éªŒæ”¶å®¡æ‰¹ â†’ ä»»åŠ¡å…³é—­
```

### 2. ä»»åŠ¡ä¸‹è¾¾æµï¼ˆé¢†å¯¼ä¸»åŠ¨åˆ†é…ï¼‰
```
é¢†å¯¼åˆ›å»ºä»»åŠ¡ â†’ å‘˜å·¥ç¡®è®¤æ¥æ”¶ â†’ å‘˜å·¥æ‰§è¡Œ â†’ å‘˜å·¥æäº¤å®Œæˆ â†’ é¢†å¯¼éªŒæ”¶å®¡æ‰¹ â†’ ä»»åŠ¡å…³é—­
```

### 3. ä»»åŠ¡å§”æ´¾æµï¼ˆå¹³çº§æˆ–è·¨éƒ¨é—¨ï¼‰
```
å‘˜å·¥Aåˆ›å»ºä»»åŠ¡ â†’ éƒ¨é—¨é¢†å¯¼å®¡æ‰¹ â†’ åˆ†é…ç»™å‘˜å·¥B â†’ å‘˜å·¥Bç¡®è®¤ â†’ æ‰§è¡Œ â†’ æäº¤ â†’ éªŒæ”¶ â†’ å…³é—­
```

## ğŸ“‹ é‡æ–°è®¾è®¡çš„çŠ¶æ€æœº

### ä»»åŠ¡ç”³è¯·æµçŠ¶æ€æœº
```mermaid
stateDiagram-v2
    [*] --> Draft : å‘˜å·¥åˆ›å»ºè‰ç¨¿
    
    Draft --> PendingApproval : å‘˜å·¥æäº¤ç”³è¯·
    Draft --> Cancelled : å‘˜å·¥å–æ¶ˆ
    
    PendingApproval --> Approved : é¢†å¯¼æ‰¹å‡†
    PendingApproval --> Rejected : é¢†å¯¼æ‹’ç»
    PendingApproval --> Cancelled : å‘˜å·¥æ’¤å›
    
    Approved --> InProgress : å‘˜å·¥å¼€å§‹æ‰§è¡Œ
    Approved --> Cancelled : å‘˜å·¥æ”¾å¼ƒ
    
    InProgress --> PendingCompletion : å‘˜å·¥æäº¤å®Œæˆ
    InProgress --> Blocked : é‡åˆ°é˜»ç¢
    InProgress --> Cancelled : ä¸­æ­¢æ‰§è¡Œ
    
    Blocked --> InProgress : è§£é™¤é˜»ç¢
    Blocked --> Cancelled : æ— æ³•ç»§ç»­
    
    PendingCompletion --> Completed : é¢†å¯¼éªŒæ”¶é€šè¿‡
    PendingCompletion --> InProgress : é¢†å¯¼è¦æ±‚è¿”å·¥
    
    Rejected --> Draft : å‘˜å·¥ä¿®æ”¹é‡æ
    Rejected --> Cancelled : å‘˜å·¥æ”¾å¼ƒ
    
    Completed --> [*]
    Cancelled --> [*]
```

### ä»»åŠ¡ä¸‹è¾¾æµçŠ¶æ€æœº
```mermaid
stateDiagram-v2
    [*] --> Draft : é¢†å¯¼åˆ›å»ºä»»åŠ¡
    
    Draft --> PendingAcceptance : é¢†å¯¼åˆ†é…ç»™å‘˜å·¥
    Draft --> Cancelled : é¢†å¯¼å–æ¶ˆ
    
    PendingAcceptance --> Accepted : å‘˜å·¥ç¡®è®¤æ¥æ”¶
    PendingAcceptance --> Declined : å‘˜å·¥æ‹’ç»æ¥æ”¶
    PendingAcceptance --> Cancelled : é¢†å¯¼æ’¤å›
    
    Declined --> PendingReassignment : éœ€è¦é‡æ–°åˆ†é…
    PendingReassignment --> PendingAcceptance : åˆ†é…ç»™å…¶ä»–å‘˜å·¥
    PendingReassignment --> Cancelled : é¢†å¯¼å–æ¶ˆä»»åŠ¡
    
    Accepted --> InProgress : å‘˜å·¥å¼€å§‹æ‰§è¡Œ
    Accepted --> Cancelled : å‘˜å·¥ç”³è¯·å–æ¶ˆ
    
    InProgress --> PendingCompletion : å‘˜å·¥æäº¤å®Œæˆ
    InProgress --> Blocked : é‡åˆ°é˜»ç¢
    
    Blocked --> InProgress : è§£é™¤é˜»ç¢
    Blocked --> Cancelled : æ— æ³•ç»§ç»­
    
    PendingCompletion --> Completed : é¢†å¯¼éªŒæ”¶é€šè¿‡
    PendingCompletion --> InProgress : é¢†å¯¼è¦æ±‚è¿”å·¥
    
    Completed --> [*]
    Cancelled --> [*]
```

## ğŸ—ï¸ é‡æ–°è®¾è®¡çš„é¢†åŸŸæ¨¡å‹

### ä»»åŠ¡èšåˆæ ¹é‡æ–°è®¾è®¡
```go
type Task struct {
    ID          TaskID
    Title       string
    Description string
    TaskType    TaskType        // ç”³è¯·ç±»å‹ï¼šSELF_APPLY, ASSIGNED, DELEGATED
    Priority    Priority
    
    // çŠ¶æ€ä¿¡æ¯
    Status      TaskStatus
    
    // å‚ä¸äººå‘˜ï¼ˆæ ¹æ®ä»»åŠ¡ç±»å‹ä¸åŒè€Œä¸åŒï¼‰
    CreatorID   UserID          // ä»»åŠ¡åˆ›å»ºè€…
    ApproverID  UserID          // å®¡æ‰¹äºº
    ExecutorID  UserID          // å®é™…æ‰§è¡Œäºº
    ReviewerID  *UserID         // éªŒæ”¶äººï¼ˆå¯èƒ½ä¸å®¡æ‰¹äººä¸åŒï¼‰
    
    // æ—¶é—´ä¿¡æ¯
    CreatedAt     time.Time
    ApprovedAt    *time.Time
    StartedAt     *time.Time
    SubmittedAt   *time.Time     // æäº¤å®Œæˆæ—¶é—´
    CompletedAt   *time.Time     // éªŒæ”¶å®Œæˆæ—¶é—´
    DueDate       *time.Time
    
    // å®¡æ‰¹å’ŒéªŒæ”¶è®°å½•
    ApprovalRecord   *Approval   // åˆ›å»ºæ—¶çš„å®¡æ‰¹è®°å½•
    CompletionRecord *Approval   // å®Œæˆæ—¶çš„éªŒæ”¶è®°å½•
    
    // é‡æ–°åˆ†é…å†å²
    AssignmentHistory []Assignment
    
    events []DomainEvent
}

// ä»»åŠ¡ç±»å‹æšä¸¾
type TaskType int
const (
    TaskTypeSelfApply TaskType = iota  // å‘˜å·¥ä¸»åŠ¨ç”³è¯·
    TaskTypeAssigned                   // é¢†å¯¼åˆ†é…
    TaskTypeDelegated                  // å§”æ´¾ä»»åŠ¡
)

// é‡æ–°åˆ†é…è®°å½•
type Assignment struct {
    FromUserID  *UserID    // åŸæ‰§è¡Œäººï¼ˆé¦–æ¬¡åˆ†é…æ—¶ä¸ºnilï¼‰
    ToUserID    UserID     // æ–°æ‰§è¡Œäºº
    AssignerID  UserID     // åˆ†é…äºº
    Reason      string     // åˆ†é…åŸå› 
    AssignedAt  time.Time
}
```

### ä¸šåŠ¡æ–¹æ³•é‡æ–°è®¾è®¡
```go
// å‘˜å·¥ç”³è¯·ä»»åŠ¡
func (t *Task) SubmitForApproval(creator *User) error {
    if t.TaskType != TaskTypeSelfApply {
        return errors.New("only self-apply tasks can be submitted for approval")
    }
    
    if t.Status != TaskStatusDraft {
        return errors.New("can only submit draft tasks")
    }
    
    t.Status = TaskStatusPendingApproval
    t.AddEvent(&TaskSubmittedEvent{...})
    return nil
}

// é¢†å¯¼åˆ†é…ä»»åŠ¡ç»™å‘˜å·¥
func (t *Task) AssignToEmployee(assigner *User, executor *User) error {
    if t.TaskType != TaskTypeAssigned {
        return errors.New("only assigned tasks can be assigned to employees")
    }
    
    if t.Status != TaskStatusDraft {
        return errors.New("can only assign draft tasks")
    }
    
    t.ExecutorID = executor.ID
    t.Status = TaskStatusPendingAcceptance
    
    // è®°å½•åˆ†é…å†å²
    assignment := Assignment{
        FromUserID:  nil,  // é¦–æ¬¡åˆ†é…
        ToUserID:    executor.ID,
        AssignerID:  assigner.ID,
        Reason:      "initial assignment",
        AssignedAt:  time.Now(),
    }
    t.AssignmentHistory = append(t.AssignmentHistory, assignment)
    
    t.AddEvent(&TaskAssignedEvent{...})
    return nil
}

// å‘˜å·¥ç¡®è®¤æ¥æ”¶ä»»åŠ¡
func (t *Task) AcceptTask(executor *User) error {
    if t.ExecutorID != executor.ID {
        return errors.New("only assigned executor can accept the task")
    }
    
    if t.Status != TaskStatusPendingAcceptance {
        return errors.New("task is not pending acceptance")
    }
    
    t.Status = TaskStatusAccepted
    t.AddEvent(&TaskAcceptedEvent{...})
    return nil
}

// å‘˜å·¥æ‹’ç»æ¥æ”¶ä»»åŠ¡
func (t *Task) DeclineTask(executor *User, reason string) error {
    if t.ExecutorID != executor.ID {
        return errors.New("only assigned executor can decline the task")
    }
    
    if t.Status != TaskStatusPendingAcceptance {
        return errors.New("task is not pending acceptance")
    }
    
    t.Status = TaskStatusDeclined
    t.AddEvent(&TaskDeclinedEvent{
        TaskID:     t.ID,
        ExecutorID: executor.ID,
        Reason:     reason,
        Timestamp:  time.Now(),
    })
    return nil
}

// é‡æ–°åˆ†é…ä»»åŠ¡
func (t *Task) ReassignTask(assigner *User, newExecutor *User, reason string) error {
    if !assigner.CanReassignTask(t) {
        return errors.New("insufficient permission to reassign task")
    }
    
    oldExecutorID := t.ExecutorID
    t.ExecutorID = newExecutor.ID
    t.Status = TaskStatusPendingAcceptance
    
    // è®°å½•é‡æ–°åˆ†é…å†å²
    assignment := Assignment{
        FromUserID:  oldExecutorID,
        ToUserID:    newExecutor.ID,
        AssignerID:  assigner.ID,
        Reason:      reason,
        AssignedAt:  time.Now(),
    }
    t.AssignmentHistory = append(t.AssignmentHistory, assignment)
    
    t.AddEvent(&TaskReassignedEvent{...})
    return nil
}

// å‘˜å·¥å¼€å§‹æ‰§è¡Œä»»åŠ¡
func (t *Task) StartExecution(executor *User) error {
    if t.ExecutorID != executor.ID {
        return errors.New("only assigned executor can start the task")
    }
    
    if t.Status != TaskStatusAccepted && t.Status != TaskStatusApproved {
        return errors.New("task must be accepted or approved to start")
    }
    
    t.Status = TaskStatusInProgress
    t.StartedAt = &time.Time{}
    *t.StartedAt = time.Now()
    
    t.AddEvent(&TaskStartedEvent{...})
    return nil
}

// å‘˜å·¥æäº¤ä»»åŠ¡å®Œæˆ
func (t *Task) SubmitCompletion(executor *User, result string) error {
    if t.ExecutorID != executor.ID {
        return errors.New("only assigned executor can submit completion")
    }
    
    if t.Status != TaskStatusInProgress {
        return errors.New("task must be in progress to submit completion")
    }
    
    t.Status = TaskStatusPendingCompletion
    now := time.Now()
    t.SubmittedAt = &now
    
    t.AddEvent(&TaskCompletionSubmittedEvent{
        TaskID:     t.ID,
        ExecutorID: executor.ID,
        Result:     result,
        Timestamp:  now,
    })
    return nil
}

// é¢†å¯¼éªŒæ”¶ä»»åŠ¡
func (t *Task) ReviewCompletion(reviewer *User, approved bool, comment string) error {
    if !reviewer.CanReviewTask(t) {
        return errors.New("insufficient permission to review task")
    }
    
    if t.Status != TaskStatusPendingCompletion {
        return errors.New("task is not pending completion review")
    }
    
    if approved {
        t.Status = TaskStatusCompleted
        now := time.Now()
        t.CompletedAt = &now
        
        t.CompletionRecord = &Approval{
            ApproverID: reviewer.ID,
            Action:     ApprovalActionApprove,
            Comment:    comment,
            Timestamp:  now,
        }
        
        t.AddEvent(&TaskCompletedEvent{...})
    } else {
        t.Status = TaskStatusInProgress  // è¿”å·¥
        
        t.CompletionRecord = &Approval{
            ApproverID: reviewer.ID,
            Action:     ApprovalActionReject,
            Comment:    comment,
            Timestamp:  time.Now(),
        }
        
        t.AddEvent(&TaskRejectedForReworkEvent{...})
    }
    
    return nil
}
```

## ğŸ”§ ç®€åŒ–çš„æŠ€æœ¯æ¶æ„

### é—®é¢˜ï¼šæ˜¯å¦ä¸€å®šéœ€è¦Kafkaå’ŒgRPCï¼Ÿ

**ç­”æ¡ˆï¼šä¸ä¸€å®šï¼** è®©æˆ‘æä¾›ä¸€ä¸ªæ¸è¿›å¼çš„æŠ€æœ¯é€‰å‹ï¼š

#### é˜¶æ®µ1ï¼šæœ€ç®€åŒ–ç‰ˆæœ¬ï¼ˆé€‚åˆå­¦ä¹ å’Œå°å›¢é˜Ÿï¼‰
```go
// ä½¿ç”¨å†…å­˜äº‹ä»¶æ€»çº¿
type InMemoryEventBus struct {
    handlers map[string][]EventHandler
    mu       sync.RWMutex
}

// ä½¿ç”¨Redisä½œä¸ºæ¶ˆæ¯é˜Ÿåˆ—
type RedisEventBus struct {
    client *redis.Client
}

func (bus *RedisEventBus) Publish(event DomainEvent) error {
    eventData, _ := json.Marshal(event)
    return bus.client.LPush(context.Background(), "events", eventData).Err()
}

// åªä½¿ç”¨HTTP APIï¼Œä¸éœ€è¦gRPC
type TaskController struct {
    taskAppService *TaskAppService
}
```

#### é˜¶æ®µ2ï¼šä¸­ç­‰è§„æ¨¡ç‰ˆæœ¬ï¼ˆé€‚åˆä¸­å‹å›¢é˜Ÿï¼‰
```go
// ä½¿ç”¨Redis Streamä½œä¸ºæ¶ˆæ¯é˜Ÿåˆ—
type RedisStreamEventBus struct {
    client *redis.Client
}

// æ·»åŠ ç®€å•çš„HTTP API + WebSocketå®æ—¶é€šçŸ¥
type NotificationService struct {
    websocketHub *WebSocketHub
    emailService *EmailService
}
```

#### é˜¶æ®µ3ï¼šä¼ä¸šçº§ç‰ˆæœ¬ï¼ˆå¤§å‹å›¢é˜Ÿå’Œé«˜å¹¶å‘ï¼‰
```go
// ä½¿ç”¨Kafka + gRPC + å¾®æœåŠ¡æ¶æ„
type KafkaEventBus struct {
    producer sarama.SyncProducer
}

type TaskGRPCServer struct {
    taskAppService *TaskAppService
}
```

### æŠ€æœ¯é€‰å‹å¯¹æ¯”è¡¨

| ç‰¹æ€§ | å†…å­˜äº‹ä»¶æ€»çº¿ | Redisæ¶ˆæ¯é˜Ÿåˆ— | Kafka |
|------|-------------|---------------|-------|
| å¤æ‚åº¦ | ä½ | ä¸­ | é«˜ |
| æ€§èƒ½ | é«˜ï¼ˆå†…å­˜ï¼‰ | ä¸­ | é«˜ |
| æŒä¹…åŒ– | æ—  | æœ‰ | æœ‰ |
| åˆ†å¸ƒå¼ | ä¸æ”¯æŒ | æ”¯æŒ | æ”¯æŒ |
| å­¦ä¹ æˆæœ¬ | ä½ | ä¸­ | é«˜ |
| é€‚ç”¨åœºæ™¯ | å­¦ä¹ ã€åŸå‹ | ä¸­å°é¡¹ç›® | å¤§å‹é¡¹ç›® |

## ğŸ“Š é‡æ–°è®¾è®¡çš„å¯ä¿¡åº¦è¯„åˆ†

| è¯„ä¼°ç»´åº¦ | åŸè®¾è®¡ | é‡æ–°è®¾è®¡ | æ”¹è¿›è¯´æ˜ |
|----------|--------|----------|----------|
| **ä¸šåŠ¡å®Œæ•´æ€§** | 6/10 | 9/10 | âœ… è¦†ç›–äº†ä¸‰ç§ä¸šåŠ¡æµç¨‹ï¼ŒåŒ…å«å®ŒæˆéªŒæ”¶ç¯èŠ‚ |
| **æµç¨‹åˆç†æ€§** | 5/10 | 9/10 | âœ… åŒºåˆ†äº†ç”³è¯·æµå’Œä¸‹è¾¾æµï¼Œç¬¦åˆå®é™…ä¸šåŠ¡ |
| **çŠ¶æ€æœºè®¾è®¡** | 7/10 | 9/10 | âœ… å¢åŠ äº†éªŒæ”¶çŠ¶æ€å’Œé‡æ–°åˆ†é…æµç¨‹ |
| **æŠ€æœ¯é€‰å‹** | 6/10 | 8/10 | âœ… æä¾›æ¸è¿›å¼é€‰å‹ï¼Œé¿å…è¿‡åº¦è®¾è®¡ |
| **å®ç”¨æ€§** | 7/10 | 9/10 | âœ… æ›´ç¬¦åˆä¼ä¸šå®é™…å·¥ä½œæµç¨‹ |

## ğŸ¯ è§£å†³æ–¹æ¡ˆæ€»ç»“

### å¯¹ä½ é—®é¢˜çš„å›ç­”ï¼š

1. **ä»»åŠ¡åˆ†é…æµç¨‹**ï¼šé‡æ–°è®¾è®¡äº†ä¸‰ç§ä¸åŒçš„ä¸šåŠ¡æµç¨‹ï¼Œæ˜ç¡®äº†æ¯ç§æµç¨‹çš„å‚ä¸è€…å’ŒçŠ¶æ€è½¬æ¢
2. **å®Œæˆå®¡æ‰¹**ï¼šå¢åŠ äº†ä»»åŠ¡å®Œæˆåçš„éªŒæ”¶å®¡æ‰¹ç¯èŠ‚ï¼ŒåŒ…å«è¿”å·¥æœºåˆ¶
3. **é¢†å¯¼åˆ›å»ºä»»åŠ¡æµ**ï¼šè¿™æ˜¯"ä»»åŠ¡ä¸‹è¾¾æµ"ï¼Œä¸"ä»»åŠ¡ç”³è¯·æµ"æ˜¯ä¸¤ç§ä¸åŒçš„ä¸šåŠ¡æ¨¡å¼
4. **é‡æ–°åˆ†é…**ï¼šè®¾è®¡äº†å®Œæ•´çš„é‡æ–°åˆ†é…æœºåˆ¶ï¼ŒåŒ…å«åˆ†é…å†å²è®°å½•
5. **æŠ€æœ¯é€‰å‹**ï¼šæä¾›äº†æ¸è¿›å¼çš„æŠ€æœ¯é€‰å‹æ–¹æ¡ˆï¼Œä»ç®€å•åˆ°å¤æ‚

# RBAC + ABAC æ··åˆæƒé™æ¨¡å‹è®¾è®¡

## ğŸ¯ æƒé™æ¨¡å‹åˆ†æ

### å½“å‰RBACè®¾è®¡çš„å±€é™æ€§

æˆ‘ä»¬çš„ä¸šåŠ¡åœºæ™¯ä¸­å­˜åœ¨å¤æ‚çš„æƒé™åˆ¤æ–­ï¼š
- **é¡¹ç›®é¢†å¯¼**åªèƒ½ç®¡ç†**è‡ªå·±è´Ÿè´£çš„é¡¹ç›®**å†…çš„ä»»åŠ¡
- **ä»»åŠ¡è´Ÿè´£äºº**åªèƒ½ç®¡ç†**è‡ªå·±è´Ÿè´£çš„ä»»åŠ¡**çš„å‚ä¸äººå‘˜
- **å»¶æœŸå®¡æ‰¹æƒé™**å–å†³äº**ç”³è¯·äººè§’è‰²**å’Œ**å®¡æ‰¹äººä¸ç”³è¯·äººçš„å…³ç³»**
- **ä»»åŠ¡æŸ¥çœ‹æƒé™**å–å†³äº**ç”¨æˆ·ä¸é¡¹ç›®/ä»»åŠ¡çš„å…³è”å…³ç³»**

è¿™äº›éƒ½æ˜¯å…¸å‹çš„**åŸºäºå±æ€§å’Œä¸Šä¸‹æ–‡**çš„æƒé™åˆ¤æ–­ï¼Œå•çº¯çš„RBACæ— æ³•å¾ˆå¥½åœ°å¤„ç†ã€‚

## ğŸ—ï¸ RBAC + ABAC æ··åˆè®¾è®¡

### 1. RBACéƒ¨åˆ†ï¼ˆåŸºç¡€è§’è‰²æƒé™ï¼‰

```sql
-- è§’è‰²å®šä¹‰ï¼ˆå·²æœ‰ï¼‰
INSERT INTO roles (id, name, description) VALUES
('role_director', 'director', 'å¤§é¢†å¯¼'),
('role_project_leader', 'project_leader', 'é¡¹ç›®é¢†å¯¼'),
('role_employee', 'employee', 'å‘˜å·¥');

-- åŸºç¡€æƒé™å®šä¹‰ï¼ˆå·²æœ‰ï¼Œä½†éœ€è¦è¡¥å……ï¼‰
INSERT INTO permissions (id, name, resource, action, description) VALUES
-- é¡¹ç›®ç®¡ç†æƒé™
('perm_project_create', 'project:create', 'project', 'create', 'åˆ›å»ºé¡¹ç›®'),
('perm_project_read', 'project:read', 'project', 'read', 'æŸ¥çœ‹é¡¹ç›®'),
('perm_project_update', 'project:update', 'project', 'update', 'æ›´æ–°é¡¹ç›®'),
('perm_project_delete', 'project:delete', 'project', 'delete', 'åˆ é™¤é¡¹ç›®'),
('perm_project_assign_manager', 'project:assign_manager', 'project', 'assign_manager', 'åˆ†é…é¡¹ç›®ç®¡ç†è€…'),

-- ä»»åŠ¡ç®¡ç†æƒé™
('perm_task_create', 'task:create', 'task', 'create', 'åˆ›å»ºä»»åŠ¡'),
('perm_task_read', 'task:read', 'task', 'read', 'æŸ¥çœ‹ä»»åŠ¡'),
('perm_task_update', 'task:update', 'task', 'update', 'æ›´æ–°ä»»åŠ¡'),
('perm_task_delete', 'task:delete', 'task', 'delete', 'åˆ é™¤ä»»åŠ¡'),
('perm_task_assign', 'task:assign', 'task', 'assign', 'åˆ†é…ä»»åŠ¡'),
('perm_task_approve', 'task:approve', 'task', 'approve', 'å®¡æ‰¹ä»»åŠ¡'),
('perm_task_execute', 'task:execute', 'task', 'execute', 'æ‰§è¡Œä»»åŠ¡'),

-- å›¢é˜Ÿç®¡ç†æƒé™
('perm_team_manage', 'team:manage', 'team', 'manage', 'ç®¡ç†å›¢é˜Ÿæˆå‘˜'),
('perm_user_manage', 'user:manage', 'user', 'manage', 'ç®¡ç†ç”¨æˆ·'),

-- å»¶æœŸå®¡æ‰¹æƒé™
('perm_extension_request', 'extension:request', 'extension', 'request', 'ç”³è¯·å»¶æœŸ'),
('perm_extension_approve', 'extension:approve', 'extension', 'approve', 'å®¡æ‰¹å»¶æœŸ');
```

### 2. ABACéƒ¨åˆ†ï¼ˆå±æ€§å’Œä¸Šä¸‹æ–‡ï¼‰

#### å±æ€§å®šä¹‰è¡¨
```sql
-- æƒé™å±æ€§å®šä¹‰è¡¨
CREATE TABLE permission_attributes (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) UNIQUE NOT NULL,
    attribute_type ENUM('user', 'resource', 'environment', 'action') NOT NULL,
    data_type ENUM('string', 'number', 'boolean', 'array', 'object') NOT NULL,
    description TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    INDEX idx_name (name),
    INDEX idx_type (attribute_type)
);

-- æ’å…¥å±æ€§å®šä¹‰
INSERT INTO permission_attributes (id, name, attribute_type, data_type, description) VALUES
-- ç”¨æˆ·å±æ€§
('attr_user_id', 'user.id', 'user', 'string', 'ç”¨æˆ·ID'),
('attr_user_role', 'user.role', 'user', 'string', 'ç”¨æˆ·è§’è‰²'),
('attr_user_department', 'user.department_id', 'user', 'string', 'ç”¨æˆ·éƒ¨é—¨ID'),
('attr_user_manager', 'user.manager_id', 'user', 'string', 'ç”¨æˆ·ç›´å±é¢†å¯¼ID'),

-- èµ„æºå±æ€§
('attr_project_owner', 'project.owner_id', 'resource', 'string', 'é¡¹ç›®æ‰€æœ‰è€…ID'),
('attr_project_manager', 'project.manager_id', 'resource', 'string', 'é¡¹ç›®ç®¡ç†è€…ID'),
('attr_project_members', 'project.member_ids', 'resource', 'array', 'é¡¹ç›®æˆå‘˜IDåˆ—è¡¨'),
('attr_task_creator', 'task.creator_id', 'resource', 'string', 'ä»»åŠ¡åˆ›å»ºè€…ID'),
('attr_task_responsible', 'task.responsible_id', 'resource', 'string', 'ä»»åŠ¡è´Ÿè´£äººID'),
('attr_task_participants', 'task.participant_ids', 'resource', 'array', 'ä»»åŠ¡å‚ä¸äººå‘˜IDåˆ—è¡¨'),
('attr_task_project', 'task.project_id', 'resource', 'string', 'ä»»åŠ¡æ‰€å±é¡¹ç›®ID'),

-- ç¯å¢ƒå±æ€§
('attr_time_now', 'env.current_time', 'environment', 'string', 'å½“å‰æ—¶é—´'),
('attr_ip_address', 'env.ip_address', 'environment', 'string', 'è¯·æ±‚IPåœ°å€'),

-- åŠ¨ä½œå±æ€§
('attr_action_type', 'action.type', 'action', 'string', 'æ“ä½œç±»å‹'),
('attr_action_target', 'action.target_id', 'action', 'string', 'æ“ä½œç›®æ ‡ID');
```

#### æƒé™ç­–ç•¥è¡¨
```sql
-- æƒé™ç­–ç•¥è¡¨ï¼ˆABACè§„åˆ™ï¼‰
CREATE TABLE permission_policies (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(200) NOT NULL,
    description TEXT,
    resource_type VARCHAR(50) NOT NULL,
    action VARCHAR(50) NOT NULL,
    effect ENUM('allow', 'deny') NOT NULL,
    conditions JSON NOT NULL,
    priority INT DEFAULT 0,
    is_active BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    INDEX idx_resource_action (resource_type, action),
    INDEX idx_priority (priority),
    INDEX idx_active (is_active)
);

-- æ’å…¥ABACç­–ç•¥è§„åˆ™
INSERT INTO permission_policies (id, name, description, resource_type, action, effect, conditions, priority) VALUES

-- é¡¹ç›®ç®¡ç†ç­–ç•¥
('policy_project_owner_full', 'é¡¹ç›®æ‰€æœ‰è€…å®Œå…¨æƒé™', 'é¡¹ç›®æ‰€æœ‰è€…å¯¹è‡ªå·±çš„é¡¹ç›®æœ‰å®Œå…¨æƒé™', 'project', '*', 'allow', 
 JSON_OBJECT('user.id', JSON_OBJECT('eq', '${resource.owner_id}')), 100),

('policy_project_manager_manage', 'é¡¹ç›®ç®¡ç†è€…ç®¡ç†æƒé™', 'é¡¹ç›®ç®¡ç†è€…å¯ä»¥ç®¡ç†è¢«åˆ†é…çš„é¡¹ç›®', 'project', 'update', 'allow',
 JSON_OBJECT('user.id', JSON_OBJECT('eq', '${resource.manager_id}')), 90),

('policy_project_member_read', 'é¡¹ç›®æˆå‘˜æŸ¥çœ‹æƒé™', 'é¡¹ç›®æˆå‘˜å¯ä»¥æŸ¥çœ‹é¡¹ç›®ä¿¡æ¯', 'project', 'read', 'allow',
 JSON_OBJECT('user.id', JSON_OBJECT('in', '${resource.member_ids}')), 80),

-- ä»»åŠ¡ç®¡ç†ç­–ç•¥
('policy_task_responsible_manage', 'ä»»åŠ¡è´Ÿè´£äººç®¡ç†æƒé™', 'ä»»åŠ¡è´Ÿè´£äººå¯ä»¥ç®¡ç†è‡ªå·±è´Ÿè´£çš„ä»»åŠ¡', 'task', '*', 'allow',
 JSON_OBJECT('user.id', JSON_OBJECT('eq', '${resource.responsible_id}')), 100),

('policy_task_creator_edit', 'ä»»åŠ¡åˆ›å»ºè€…ç¼–è¾‘æƒé™', 'ä»»åŠ¡åˆ›å»ºè€…å¯ä»¥ç¼–è¾‘è‰ç¨¿çŠ¶æ€çš„ä»»åŠ¡', 'task', 'update', 'allow',
 JSON_OBJECT(
   'and', JSON_ARRAY(
     JSON_OBJECT('user.id', JSON_OBJECT('eq', '${resource.creator_id}')),
     JSON_OBJECT('resource.status', JSON_OBJECT('eq', 'draft'))
   )
 ), 90),

('policy_task_participant_read', 'ä»»åŠ¡å‚ä¸è€…æŸ¥çœ‹æƒé™', 'ä»»åŠ¡å‚ä¸è€…å¯ä»¥æŸ¥çœ‹ä»»åŠ¡è¯¦æƒ…', 'task', 'read', 'allow',
 JSON_OBJECT('user.id', JSON_OBJECT('in', '${resource.participant_ids}')), 80),

('policy_task_project_manager', 'é¡¹ç›®ç®¡ç†è€…ä»»åŠ¡æƒé™', 'é¡¹ç›®ç®¡ç†è€…å¯ä»¥ç®¡ç†é¡¹ç›®å†…çš„ä»»åŠ¡', 'task', '*', 'allow',
 JSON_OBJECT('user.id', JSON_OBJECT('eq', '${project.manager_id}')), 85),

-- å»¶æœŸç”³è¯·ç­–ç•¥
('policy_extension_self_request', 'è‡ªå·±ç”³è¯·å»¶æœŸ', 'ç”¨æˆ·å¯ä»¥ä¸ºè‡ªå·±çš„ä»»åŠ¡ç”³è¯·å»¶æœŸ', 'extension', 'request', 'allow',
 JSON_OBJECT(
   'or', JSON_ARRAY(
     JSON_OBJECT('user.id', JSON_OBJECT('eq', '${task.responsible_id}')),
     JSON_OBJECT('user.id', JSON_OBJECT('in', '${task.participant_ids}'))
   )
 ), 100),

('policy_extension_responsible_approve', 'ä»»åŠ¡è´Ÿè´£äººå®¡æ‰¹å»¶æœŸ', 'ä»»åŠ¡è´Ÿè´£äººå¯ä»¥å®¡æ‰¹å‚ä¸äººå‘˜çš„å»¶æœŸç”³è¯·', 'extension', 'approve', 'allow',
 JSON_OBJECT(
   'and', JSON_ARRAY(
     JSON_OBJECT('user.id', JSON_OBJECT('eq', '${task.responsible_id}')),
     JSON_OBJECT('extension.requester_id', JSON_OBJECT('in', '${task.participant_ids}'))
   )
 ), 100),

('policy_extension_project_leader_approve', 'é¡¹ç›®é¢†å¯¼å®¡æ‰¹è´Ÿè´£äººå»¶æœŸ', 'é¡¹ç›®é¢†å¯¼å¯ä»¥å®¡æ‰¹ä»»åŠ¡è´Ÿè´£äººçš„å»¶æœŸç”³è¯·', 'extension', 'approve', 'allow',
 JSON_OBJECT(
   'and', JSON_ARRAY(
     JSON_OBJECT('user.id', JSON_OBJECT('eq', '${project.manager_id}')),
     JSON_OBJECT('extension.requester_id', JSON_OBJECT('eq', '${task.responsible_id}'))
   )
 ), 90),

('policy_extension_director_approve', 'å¤§é¢†å¯¼å®¡æ‰¹å»¶æœŸ', 'å¤§é¢†å¯¼å¯ä»¥å®¡æ‰¹ä»»ä½•å»¶æœŸç”³è¯·', 'extension', 'approve', 'allow',
 JSON_OBJECT('user.role', JSON_OBJECT('eq', 'director')), 95);
```

### 3. æƒé™è¯„ä¼°å¼•æ“

#### Goä»£ç å®ç°
```go
// æƒé™è¯„ä¼°æœåŠ¡
type PermissionEvaluator struct {
    policyRepo PolicyRepository
    attrRepo   AttributeRepository
    cache      Cache
}

// æƒé™è¯„ä¼°ä¸Šä¸‹æ–‡
type EvaluationContext struct {
    User        *User                  `json:"user"`
    Resource    map[string]interface{} `json:"resource"`
    Action      string                 `json:"action"`
    Environment map[string]interface{} `json:"environment"`
}

// æƒé™ç­–ç•¥
type Policy struct {
    ID           string                 `json:"id"`
    Name         string                 `json:"name"`
    ResourceType string                 `json:"resource_type"`
    Action       string                 `json:"action"`
    Effect       string                 `json:"effect"` // allow, deny
    Conditions   map[string]interface{} `json:"conditions"`
    Priority     int                    `json:"priority"`
    IsActive     bool                   `json:"is_active"`
}

// æƒé™è¯„ä¼°ä¸»æ–¹æ³•
func (e *PermissionEvaluator) Evaluate(ctx *EvaluationContext) (bool, error) {
    // 1. è·å–é€‚ç”¨çš„ç­–ç•¥
    policies, err := e.getApplicablePolicies(ctx.Resource["type"].(string), ctx.Action)
    if err != nil {
        return false, err
    }
    
    // 2. æŒ‰ä¼˜å…ˆçº§æ’åº
    sort.Slice(policies, func(i, j int) bool {
        return policies[i].Priority > policies[j].Priority
    })
    
    // 3. é€ä¸ªè¯„ä¼°ç­–ç•¥
    for _, policy := range policies {
        if !policy.IsActive {
            continue
        }
        
        match, err := e.evaluateConditions(policy.Conditions, ctx)
        if err != nil {
            continue // è¯„ä¼°é”™è¯¯ï¼Œè·³è¿‡è¯¥ç­–ç•¥
        }
        
        if match {
            return policy.Effect == "allow", nil
        }
    }
    
    // 4. é»˜è®¤æ‹’ç»
    return false, nil
}

// æ¡ä»¶è¯„ä¼°
func (e *PermissionEvaluator) evaluateConditions(
    conditions map[string]interface{}, 
    ctx *EvaluationContext,
) (bool, error) {
    return e.evaluateCondition(conditions, ctx)
}

func (e *PermissionEvaluator) evaluateCondition(
    condition interface{}, 
    ctx *EvaluationContext,
) (bool, error) {
    switch cond := condition.(type) {
    case map[string]interface{}:
        // å¤„ç†é€»è¾‘æ“ä½œç¬¦
        if andConditions, ok := cond["and"]; ok {
            return e.evaluateAndCondition(andConditions, ctx)
        }
        if orConditions, ok := cond["or"]; ok {
            return e.evaluateOrCondition(orConditions, ctx)
        }
        if notCondition, ok := cond["not"]; ok {
            result, err := e.evaluateCondition(notCondition, ctx)
            return !result, err
        }
        
        // å¤„ç†å±æ€§æ¯”è¾ƒ
        for attr, comparison := range cond {
            return e.evaluateComparison(attr, comparison, ctx)
        }
    }
    
    return false, fmt.Errorf("unsupported condition type")
}

func (e *PermissionEvaluator) evaluateAndCondition(
    conditions interface{}, 
    ctx *EvaluationContext,
) (bool, error) {
    condArray, ok := conditions.([]interface{})
    if !ok {
        return false, fmt.Errorf("and condition must be an array")
    }
    
    for _, cond := range condArray {
        result, err := e.evaluateCondition(cond, ctx)
        if err != nil {
            return false, err
        }
        if !result {
            return false, nil
        }
    }
    return true, nil
}

func (e *PermissionEvaluator) evaluateOrCondition(
    conditions interface{}, 
    ctx *EvaluationContext,
) (bool, error) {
    condArray, ok := conditions.([]interface{})
    if !ok {
        return false, fmt.Errorf("or condition must be an array")
    }
    
    for _, cond := range condArray {
        result, err := e.evaluateCondition(cond, ctx)
        if err != nil {
            continue // å¿½ç•¥é”™è¯¯ï¼Œç»§ç»­ä¸‹ä¸€ä¸ªæ¡ä»¶
        }
        if result {
            return true, nil
        }
    }
    return false, nil
}

func (e *PermissionEvaluator) evaluateComparison(
    attribute string, 
    comparison interface{}, 
    ctx *EvaluationContext,
) (bool, error) {
    // è·å–å±æ€§å€¼
    attrValue, err := e.getAttributeValue(attribute, ctx)
    if err != nil {
        return false, err
    }
    
    compMap, ok := comparison.(map[string]interface{})
    if !ok {
        return false, fmt.Errorf("comparison must be an object")
    }
    
    for operator, expectedValue := range compMap {
        return e.applyOperator(attrValue, operator, expectedValue, ctx)
    }
    
    return false, nil
}

func (e *PermissionEvaluator) getAttributeValue(
    attribute string, 
    ctx *EvaluationContext,
) (interface{}, error) {
    // è§£æå±æ€§è·¯å¾„ï¼Œå¦‚ "user.id", "resource.owner_id", "task.responsible_id"
    parts := strings.Split(attribute, ".")
    if len(parts) < 2 {
        return nil, fmt.Errorf("invalid attribute format: %s", attribute)
    }
    
    var source map[string]interface{}
    switch parts[0] {
    case "user":
        userMap, _ := json.Marshal(ctx.User)
        json.Unmarshal(userMap, &source)
    case "resource":
        source = ctx.Resource
    case "env", "environment":
        source = ctx.Environment
    case "project":
        // éœ€è¦æ ¹æ®task.project_idè·å–projectä¿¡æ¯
        if projectID, ok := ctx.Resource["project_id"].(string); ok {
            project, err := e.getProjectInfo(projectID)
            if err != nil {
                return nil, err
            }
            projectMap, _ := json.Marshal(project)
            json.Unmarshal(projectMap, &source)
        }
    case "task":
        // å¦‚æœæ˜¯extensionèµ„æºï¼Œéœ€è¦è·å–å¯¹åº”çš„taskä¿¡æ¯
        if ctx.Resource["type"] == "extension" {
            if taskID, ok := ctx.Resource["task_id"].(string); ok {
                task, err := e.getTaskInfo(taskID)
                if err != nil {
                    return nil, err
                }
                taskMap, _ := json.Marshal(task)
                json.Unmarshal(taskMap, &source)
            }
        } else {
            source = ctx.Resource
        }
    default:
        return nil, fmt.Errorf("unknown attribute source: %s", parts[0])
    }
    
    // è·å–åµŒå¥—å±æ€§å€¼
    value := source
    for i := 1; i < len(parts); i++ {
        if nextValue, ok := value[parts[i]]; ok {
            if i == len(parts)-1 {
                return nextValue, nil
            }
            if nextMap, ok := nextValue.(map[string]interface{}); ok {
                value = nextMap
            } else {
                return nil, fmt.Errorf("cannot access nested attribute: %s", attribute)
            }
        } else {
            return nil, fmt.Errorf("attribute not found: %s", attribute)
        }
    }
    
    return nil, fmt.Errorf("attribute value not found: %s", attribute)
}

func (e *PermissionEvaluator) applyOperator(
    attrValue interface{}, 
    operator string, 
    expectedValue interface{}, 
    ctx *EvaluationContext,
) (bool, error) {
    // å¤„ç†å˜é‡æ›¿æ¢ï¼Œå¦‚ "${resource.owner_id}"
    if expectedStr, ok := expectedValue.(string); ok {
        if strings.HasPrefix(expectedStr, "${") && strings.HasSuffix(expectedStr, "}") {
            varPath := strings.TrimSuffix(strings.TrimPrefix(expectedStr, "${"), "}")
            resolvedValue, err := e.getAttributeValue(varPath, ctx)
            if err != nil {
                return false, err
            }
            expectedValue = resolvedValue
        }
    }
    
    switch operator {
    case "eq", "equals":
        return reflect.DeepEqual(attrValue, expectedValue), nil
    case "ne", "not_equals":
        return !reflect.DeepEqual(attrValue, expectedValue), nil
    case "in":
        return e.checkInArray(attrValue, expectedValue)
    case "not_in":
        result, err := e.checkInArray(attrValue, expectedValue)
        return !result, err
    case "gt", "greater_than":
        return e.compareNumbers(attrValue, expectedValue, ">")
    case "gte", "greater_than_or_equal":
        return e.compareNumbers(attrValue, expectedValue, ">=")
    case "lt", "less_than":
        return e.compareNumbers(attrValue, expectedValue, "<")
    case "lte", "less_than_or_equal":
        return e.compareNumbers(attrValue, expectedValue, "<=")
    case "contains":
        return e.checkContains(attrValue, expectedValue)
    case "starts_with":
        return e.checkStartsWith(attrValue, expectedValue)
    case "ends_with":
        return e.checkEndsWith(attrValue, expectedValue)
    default:
        return false, fmt.Errorf("unsupported operator: %s", operator)
    }
}

// è¾…åŠ©æ–¹æ³•å®ç°
func (e *PermissionEvaluator) checkInArray(value, array interface{}) (bool, error) {
    arrayValue := reflect.ValueOf(array)
    if arrayValue.Kind() != reflect.Slice && arrayValue.Kind() != reflect.Array {
        return false, fmt.Errorf("expected array for 'in' operator")
    }
    
    for i := 0; i < arrayValue.Len(); i++ {
        if reflect.DeepEqual(value, arrayValue.Index(i).Interface()) {
            return true, nil
        }
    }
    return false, nil
}

// æƒé™æ£€æŸ¥çš„ä¾¿æ·æ–¹æ³•
func (e *PermissionEvaluator) CanUserAccessProject(userID, projectID string) (bool, error) {
    user, err := e.getUserInfo(userID)
    if err != nil {
        return false, err
    }
    
    project, err := e.getProjectInfo(projectID)
    if err != nil {
        return false, err
    }
    
    ctx := &EvaluationContext{
        User: user,
        Resource: map[string]interface{}{
            "type":       "project",
            "id":         project.ID,
            "owner_id":   project.OwnerID,
            "manager_id": project.ManagerID,
            "member_ids": project.GetMemberIDs(),
        },
        Action: "read",
        Environment: map[string]interface{}{
            "current_time": time.Now().Format(time.RFC3339),
        },
    }
    
    return e.Evaluate(ctx)
}

func (e *PermissionEvaluator) CanUserManageTask(userID, taskID string) (bool, error) {
    user, err := e.getUserInfo(userID)
    if err != nil {
        return false, err
    }
    
    task, err := e.getTaskInfo(taskID)
    if err != nil {
        return false, err
    }
    
    project, err := e.getProjectInfo(task.ProjectID)
    if err != nil {
        return false, err
    }
    
    ctx := &EvaluationContext{
        User: user,
        Resource: map[string]interface{}{
            "type":            "task",
            "id":              task.ID,
            "creator_id":      task.CreatorID,
            "responsible_id":  task.ResponsibleID,
            "participant_ids": task.ParticipantIDs,
            "project_id":      task.ProjectID,
            "status":          task.Status,
        },
        Action: "update",
        Environment: map[string]interface{}{
            "current_time": time.Now().Format(time.RFC3339),
        },
    }
    
    // æ·»åŠ é¡¹ç›®ä¿¡æ¯åˆ°ä¸Šä¸‹æ–‡
    ctx.Resource["project"] = map[string]interface{}{
        "owner_id":   project.OwnerID,
        "manager_id": project.ManagerID,
    }
    
    return e.Evaluate(ctx)
}
```

## ğŸ”§ å…¶ä»–æŠ€æœ¯ç»†èŠ‚è¡¥å……

### 1. å¤§æ–‡ä»¶ä¸Šä¼ å’Œæ–­ç‚¹ç»­ä¼ 

#### æ–‡ä»¶ä¸Šä¼ APIè®¾è®¡
```http
# åˆå§‹åŒ–ä¸Šä¼ 
POST /api/v1/files/upload/init
Content-Type: application/json
{
  "filename": "document.pdf",
  "size": 10485760,
  "content_type": "application/pdf",
  "chunk_size": 1048576
}

# ä¸Šä¼ åˆ†ç‰‡
PUT /api/v1/files/upload/{upload_id}/chunks/{chunk_number}
Content-Type: application/octet-stream
Content-Range: bytes 0-1048575/10485760

# å®Œæˆä¸Šä¼ 
POST /api/v1/files/upload/{upload_id}/complete
{
  "chunks": [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
}

# æŸ¥è¯¢ä¸Šä¼ çŠ¶æ€
GET /api/v1/files/upload/{upload_id}/status
```

#### æ•°æ®åº“è®¾è®¡
```sql
-- æ–‡ä»¶ä¸Šä¼ è®°å½•è¡¨
CREATE TABLE file_uploads (
    id VARCHAR(36) PRIMARY KEY,
    filename VARCHAR(500) NOT NULL,
    original_filename VARCHAR(500) NOT NULL,
    content_type VARCHAR(200),
    file_size BIGINT NOT NULL,
    chunk_size INT DEFAULT 1048576,
    total_chunks INT NOT NULL,
    uploaded_chunks JSON,
    status ENUM('pending', 'uploading', 'completed', 'failed') DEFAULT 'pending',
    file_path VARCHAR(1000),
    uploader_id VARCHAR(36),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    completed_at TIMESTAMP NULL,
    
    FOREIGN KEY (uploader_id) REFERENCES users(id),
    INDEX idx_uploader (uploader_id),
    INDEX idx_status (status),
    INDEX idx_created_at (created_at)
);

-- æ–‡ä»¶å…³è”è¡¨ï¼ˆä»»åŠ¡é™„ä»¶ã€ç”¨æˆ·å¤´åƒç­‰ï¼‰
CREATE TABLE file_attachments (
    id VARCHAR(36) PRIMARY KEY,
    file_id VARCHAR(36) NOT NULL,
    resource_type VARCHAR(50) NOT NULL,
    resource_id VARCHAR(36) NOT NULL,
    attachment_type VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    
    FOREIGN KEY (file_id) REFERENCES file_uploads(id) ON DELETE CASCADE,
    INDEX idx_resource (resource_type, resource_id),
    INDEX idx_file (file_id)
);
```

### 2. MySQLå…¨æ–‡æœç´¢è®¾è®¡

```sql
-- ä¸ºä»»åŠ¡è¡¨æ·»åŠ å…¨æ–‡ç´¢å¼•
ALTER TABLE tasks ADD FULLTEXT INDEX ft_title_description (title, description);

-- ä¸ºé¡¹ç›®è¡¨æ·»åŠ å…¨æ–‡ç´¢å¼•  
ALTER TABLE projects ADD FULLTEXT INDEX ft_name_description (name, description);

-- æœç´¢APIå®ç°
SELECT t.*, p.name as project_name,
       MATCH(t.title, t.description) AGAINST(? IN NATURAL LANGUAGE MODE) as relevance_score
FROM tasks t
JOIN projects p ON t.project_id = p.id
WHERE MATCH(t.title, t.description) AGAINST(? IN NATURAL LANGUAGE MODE)
   OR MATCH(p.name, p.description) AGAINST(? IN NATURAL LANGUAGE MODE)
ORDER BY relevance_score DESC
LIMIT 20;
```

### 3. ä¼ä¸šçº§æµ‹è¯•æ–¹æ¡ˆè®¾è®¡

#### æµ‹è¯•æ¶æ„
```
æµ‹è¯•é‡‘å­—å¡”
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   E2E Tests â”‚  (å°‘é‡ï¼Œå…³é”®ä¸šåŠ¡æµç¨‹)
    â”‚   (5-10%)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚Integration  â”‚  (ä¸­é‡ï¼ŒAPIå’Œæ•°æ®åº“é›†æˆ)
    â”‚   Tests     â”‚
    â”‚   (20-30%)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ Unit Tests  â”‚  (å¤§é‡ï¼Œä¸šåŠ¡é€»è¾‘å’Œé¢†åŸŸæ¨¡å‹)
    â”‚   (60-75%)  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### æµ‹è¯•ç›®å½•ç»“æ„
```
test/
â”œâ”€â”€ unit/                   # å•å…ƒæµ‹è¯•
â”‚   â”œâ”€â”€ domain/            # é¢†åŸŸå±‚æµ‹è¯•
â”‚   â”œâ”€â”€ application/       # åº”ç”¨æœåŠ¡å±‚æµ‹è¯•
â”‚   â””â”€â”€ infrastructure/    # åŸºç¡€è®¾æ–½å±‚æµ‹è¯•
â”œâ”€â”€ integration/           # é›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ api/              # APIé›†æˆæµ‹è¯•
â”‚   â”œâ”€â”€ database/         # æ•°æ®åº“é›†æˆæµ‹è¯•
â”‚   â””â”€â”€ external/         # å¤–éƒ¨æœåŠ¡é›†æˆæµ‹è¯•
â”œâ”€â”€ e2e/                  # ç«¯åˆ°ç«¯æµ‹è¯•
â”‚   â”œâ”€â”€ scenarios/        # ä¸šåŠ¡åœºæ™¯æµ‹è¯•
â”‚   â””â”€â”€ fixtures/         # æµ‹è¯•æ•°æ®
â”œâ”€â”€ performance/          # æ€§èƒ½æµ‹è¯•
â””â”€â”€ testdata/            # æµ‹è¯•æ•°æ®å’ŒMock
    â”œâ”€â”€ fixtures/
    â””â”€â”€ mocks/
```

## âœ… éœ€æ±‚ç¡®è®¤æ€»ç»“

åŸºäºä½ çš„ç¡®è®¤ï¼Œæˆ‘ç†è§£æˆ‘ä»¬éœ€è¦ï¼š

1. **æƒé™ç³»ç»Ÿ**ï¼šRBAC + ABACæ··åˆæ¨¡å‹ï¼Œæ”¯æŒå¤æ‚çš„å±æ€§å’Œä¸Šä¸‹æ–‡åˆ¤æ–­
2. **æ–‡ä»¶ç³»ç»Ÿ**ï¼šæœ¬åœ°å­˜å‚¨ + å¤§æ–‡ä»¶åˆ†ç‰‡ä¸Šä¼  + æ–­ç‚¹ç»­ä¼ 
3. **æœç´¢åŠŸèƒ½**ï¼šMySQL FULLTEXTç´¢å¼•å®ç°
4. **æµ‹è¯•ä½“ç³»**ï¼šå®Œæ•´çš„å•å…ƒæµ‹è¯•ã€é›†æˆæµ‹è¯•ã€E2Eæµ‹è¯•æ–¹æ¡ˆ
5. **APIæ–‡æ¡£**ï¼šSwagger/OpenAPIæ–‡æ¡£è‡ªåŠ¨ç”Ÿæˆ


