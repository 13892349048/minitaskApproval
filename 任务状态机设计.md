# ä»»åŠ¡å®¡æ‰¹æµçŠ¶æ€æœºè®¾è®¡

## ğŸ”„ çŠ¶æ€è½¬æ¢å›¾

```mermaid
stateDiagram-v2
    [*] --> Draft : åˆ›å»ºä»»åŠ¡
    
    Draft --> Pending : submit()
    Draft --> Cancelled : cancel()
    
    Pending --> Approved : approve()
    Pending --> Rejected : reject()
    Pending --> Cancelled : cancel()
    
    Approved --> InProgress : assign()
    Approved --> Cancelled : cancel()
    
    InProgress --> Completed : complete()
    InProgress --> Blocked : block()
    InProgress --> Cancelled : cancel()
    
    Blocked --> InProgress : unblock()
    Blocked --> Cancelled : cancel()
    
    Rejected --> Draft : resubmit()
    Rejected --> Cancelled : cancel()
    
    Completed --> [*]
    Cancelled --> [*]
```

## ğŸ“‹ çŠ¶æ€å®šä¹‰å’Œè§„åˆ™

### çŠ¶æ€æšä¸¾
```go
type TaskStatus int

const (
    TaskStatusDraft TaskStatus = iota      // è‰ç¨¿
    TaskStatusPending                      // å¾…å®¡æ‰¹  
    TaskStatusApproved                     // å·²æ‰¹å‡†
    TaskStatusInProgress                   // æ‰§è¡Œä¸­
    TaskStatusCompleted                    // å·²å®Œæˆ
    TaskStatusRejected                     // å·²æ‹’ç»
    TaskStatusBlocked                      // é˜»å¡
    TaskStatusCancelled                    // å·²å–æ¶ˆ
)
```

### çŠ¶æ€è½¬æ¢è§„åˆ™è¡¨

| å½“å‰çŠ¶æ€ | å…è®¸è½¬æ¢åˆ° | è§¦å‘æ¡ä»¶ | æƒé™è¦æ±‚ |
|----------|------------|----------|----------|
| Draft | Pending | ä»»åŠ¡ä¿¡æ¯å®Œæ•´ | åˆ›å»ºè€… |
| Draft | Cancelled | ä»»æ„æ—¶é—´ | åˆ›å»ºè€… |
| Pending | Approved | å®¡æ‰¹é€šè¿‡ | å®¡æ‰¹äºº |
| Pending | Rejected | å®¡æ‰¹æ‹’ç» | å®¡æ‰¹äºº |
| Pending | Cancelled | æ’¤é”€ç”³è¯· | åˆ›å»ºè€… |
| Approved | InProgress | åˆ†é…æ‰§è¡Œäºº | ç®¡ç†è€… |
| Approved | Cancelled | å–æ¶ˆä»»åŠ¡ | åˆ›å»ºè€…/ç®¡ç†è€… |
| InProgress | Completed | ä»»åŠ¡å®Œæˆ | æ‰§è¡Œäºº |
| InProgress | Blocked | é‡åˆ°é˜»ç¢ | æ‰§è¡Œäºº |
| InProgress | Cancelled | å–æ¶ˆæ‰§è¡Œ | ç®¡ç†è€… |
| Blocked | InProgress | è§£é™¤é˜»å¡ | æ‰§è¡Œäºº/ç®¡ç†è€… |
| Blocked | Cancelled | æ— æ³•ç»§ç»­ | ç®¡ç†è€… |
| Rejected | Draft | é‡æ–°ç¼–è¾‘ | åˆ›å»ºè€… |
| Rejected | Cancelled | æ”¾å¼ƒä»»åŠ¡ | åˆ›å»ºè€… |

## ğŸ›¡ï¸ çŠ¶æ€æœºå®ç°

```go
// çŠ¶æ€æœºæ¥å£
type TaskStateMachine interface {
    CanTransition(from, to TaskStatus) bool
    ValidateTransition(task *Task, to TaskStatus, actor *User) error
    Transition(task *Task, to TaskStatus, actor *User) error
}

// çŠ¶æ€æœºå®ç°
type taskStateMachine struct {
    transitions map[TaskStatus][]TaskStatus
}

func NewTaskStateMachine() TaskStateMachine {
    transitions := map[TaskStatus][]TaskStatus{
        TaskStatusDraft: {
            TaskStatusPending,
            TaskStatusCancelled,
        },
        TaskStatusPending: {
            TaskStatusApproved,
            TaskStatusRejected,
            TaskStatusCancelled,
        },
        TaskStatusApproved: {
            TaskStatusInProgress,
            TaskStatusCancelled,
        },
        TaskStatusInProgress: {
            TaskStatusCompleted,
            TaskStatusBlocked,
            TaskStatusCancelled,
        },
        TaskStatusBlocked: {
            TaskStatusInProgress,
            TaskStatusCancelled,
        },
        TaskStatusRejected: {
            TaskStatusDraft,
            TaskStatusCancelled,
        },
    }
    
    return &taskStateMachine{
        transitions: transitions,
    }
}

func (sm *taskStateMachine) CanTransition(from, to TaskStatus) bool {
    allowedStates, exists := sm.transitions[from]
    if !exists {
        return false
    }
    
    for _, allowedState := range allowedStates {
        if allowedState == to {
            return true
        }
    }
    return false
}

func (sm *taskStateMachine) ValidateTransition(task *Task, to TaskStatus, actor *User) error {
    // 1. æ£€æŸ¥çŠ¶æ€è½¬æ¢æ˜¯å¦åˆæ³•
    if !sm.CanTransition(task.Status, to) {
        return fmt.Errorf("invalid transition from %v to %v", task.Status, to)
    }
    
    // 2. æ£€æŸ¥æƒé™
    switch to {
    case TaskStatusPending:
        if task.CreatorID != actor.ID {
            return errors.New("only creator can submit task")
        }
    case TaskStatusApproved, TaskStatusRejected:
        if task.ApproverID != actor.ID {
            return errors.New("only assigned approver can approve/reject task")
        }
    case TaskStatusInProgress:
        if !actor.CanAssign(task) {
            return errors.New("insufficient permission to assign task")
        }
    case TaskStatusCompleted:
        if task.AssigneeID == nil || *task.AssigneeID != actor.ID {
            return errors.New("only assignee can complete task")
        }
    case TaskStatusBlocked:
        if task.AssigneeID == nil || *task.AssigneeID != actor.ID {
            return errors.New("only assignee can block task")
        }
    }
    
    // 3. æ£€æŸ¥ä¸šåŠ¡è§„åˆ™
    switch to {
    case TaskStatusPending:
        if task.Title == "" || task.Description == "" {
            return errors.New("task title and description are required")
        }
    case TaskStatusInProgress:
        if task.AssigneeID == nil {
            return errors.New("assignee is required for in-progress task")
        }
    }
    
    return nil
}

func (sm *taskStateMachine) Transition(task *Task, to TaskStatus, actor *User) error {
    if err := sm.ValidateTransition(task, to, actor); err != nil {
        return err
    }
    
    oldStatus := task.Status
    task.Status = to
    task.UpdatedAt = time.Now()
    
    // å‘å¸ƒçŠ¶æ€è½¬æ¢äº‹ä»¶
    event := &TaskStatusChangedEvent{
        TaskID:    task.ID,
        OldStatus: oldStatus,
        NewStatus: to,
        ActorID:   actor.ID,
        Timestamp: time.Now(),
    }
    
    task.AddEvent(event)
    return nil
}
```

## ğŸ¯ ä¸šåŠ¡æ–¹æ³•é›†æˆçŠ¶æ€æœº

```go
// Task èšåˆæ ¹ä¸­é›†æˆçŠ¶æ€æœº
type Task struct {
    // ... å…¶ä»–å­—æ®µ
    stateMachine TaskStateMachine
}

func (t *Task) Submit(actor *User) error {
    return t.stateMachine.Transition(t, TaskStatusPending, actor)
}

func (t *Task) Approve(approver *User, comment string) error {
    if err := t.stateMachine.Transition(t, TaskStatusApproved, approver); err != nil {
        return err
    }
    
    // æ·»åŠ å®¡æ‰¹è®°å½•
    approval := Approval{
        ApproverID: approver.ID,
        Action:     ApprovalActionApprove,
        Comment:    comment,
        Timestamp:  time.Now(),
    }
    t.Approvals = append(t.Approvals, approval)
    
    // å‘å¸ƒå®¡æ‰¹äº‹ä»¶
    t.AddEvent(&TaskApprovedEvent{
        TaskID:     t.ID,
        ApproverID: approver.ID,
        Comment:    comment,
        Timestamp:  time.Now(),
    })
    
    return nil
}

func (t *Task) Reject(approver *User, reason string) error {
    if err := t.stateMachine.Transition(t, TaskStatusRejected, approver); err != nil {
        return err
    }
    
    // æ·»åŠ æ‹’ç»è®°å½•
    approval := Approval{
        ApproverID: approver.ID,
        Action:     ApprovalActionReject,
        Comment:    reason,
        Timestamp:  time.Now(),
    }
    t.Approvals = append(t.Approvals, approval)
    
    return nil
}

func (t *Task) Assign(assignee *User, assigner *User) error {
    if err := t.stateMachine.Transition(t, TaskStatusInProgress, assigner); err != nil {
        return err
    }
    
    t.AssigneeID = &assignee.ID
    
    // å‘å¸ƒåˆ†é…äº‹ä»¶
    t.AddEvent(&TaskAssignedEvent{
        TaskID:     t.ID,
        AssigneeID: assignee.ID,
        AssignerID: assigner.ID,
        Timestamp:  time.Now(),
    })
    
    return nil
}

func (t *Task) Complete(assignee *User, result string) error {
    if err := t.stateMachine.Transition(t, TaskStatusCompleted, assignee); err != nil {
        return err
    }
    
    now := time.Now()
    t.CompletedAt = &now
    t.Result = result
    
    // å‘å¸ƒå®Œæˆäº‹ä»¶
    t.AddEvent(&TaskCompletedEvent{
        TaskID:     t.ID,
        AssigneeID: assignee.ID,
        Result:     result,
        Timestamp:  now,
    })
    
    return nil
}
```

## ğŸ“Š çŠ¶æ€ç»Ÿè®¡å’ŒæŠ¥è¡¨

```go
// ä»»åŠ¡çŠ¶æ€ç»Ÿè®¡
type TaskStatusStats struct {
    Draft      int `json:"draft"`
    Pending    int `json:"pending"`
    Approved   int `json:"approved"`
    InProgress int `json:"in_progress"`
    Completed  int `json:"completed"`
    Rejected   int `json:"rejected"`
    Blocked    int `json:"blocked"`
    Cancelled  int `json:"cancelled"`
    Total      int `json:"total"`
}

// çŠ¶æ€ç»Ÿè®¡æœåŠ¡
type TaskStatsService struct {
    taskRepo TaskRepository
}

func (s *TaskStatsService) GetUserTaskStats(userID UserID) (*TaskStatusStats, error) {
    tasks, err := s.taskRepo.FindByCreator(userID)
    if err != nil {
        return nil, err
    }
    
    stats := &TaskStatusStats{}
    for _, task := range tasks {
        switch task.Status {
        case TaskStatusDraft:
            stats.Draft++
        case TaskStatusPending:
            stats.Pending++
        case TaskStatusApproved:
            stats.Approved++
        case TaskStatusInProgress:
            stats.InProgress++
        case TaskStatusCompleted:
            stats.Completed++
        case TaskStatusRejected:
            stats.Rejected++
        case TaskStatusBlocked:
            stats.Blocked++
        case TaskStatusCancelled:
            stats.Cancelled++
        }
        stats.Total++
    }
    
    return stats, nil
}
```

## ğŸ§ª çŠ¶æ€æœºæµ‹è¯•ç”¨ä¾‹

```go
func TestTaskStateMachine(t *testing.T) {
    sm := NewTaskStateMachine()
    
    // æµ‹è¯•æ­£å¸¸æµç¨‹
    assert.True(t, sm.CanTransition(TaskStatusDraft, TaskStatusPending))
    assert.True(t, sm.CanTransition(TaskStatusPending, TaskStatusApproved))
    assert.True(t, sm.CanTransition(TaskStatusApproved, TaskStatusInProgress))
    assert.True(t, sm.CanTransition(TaskStatusInProgress, TaskStatusCompleted))
    
    // æµ‹è¯•éæ³•è½¬æ¢
    assert.False(t, sm.CanTransition(TaskStatusDraft, TaskStatusApproved))
    assert.False(t, sm.CanTransition(TaskStatusCompleted, TaskStatusPending))
    
    // æµ‹è¯•æƒé™éªŒè¯
    task := &Task{
        Status:     TaskStatusPending,
        CreatorID:  UserID("creator"),
        ApproverID: UserID("approver"),
    }
    
    wrongUser := &User{ID: UserID("wrong")}
    approver := &User{ID: UserID("approver")}
    
    // éå®¡æ‰¹äººä¸èƒ½å®¡æ‰¹
    err := sm.ValidateTransition(task, TaskStatusApproved, wrongUser)
    assert.Error(t, err)
    
    // å®¡æ‰¹äººå¯ä»¥å®¡æ‰¹
    err = sm.ValidateTransition(task, TaskStatusApproved, approver)
    assert.NoError(t, err)
}
```

è¿™ä¸ªçŠ¶æ€æœºè®¾è®¡ç¡®ä¿äº†ï¼š
1. **çŠ¶æ€è½¬æ¢çš„åˆæ³•æ€§**ï¼šåªå…è®¸é¢„å®šä¹‰çš„çŠ¶æ€è½¬æ¢
2. **æƒé™æ§åˆ¶**ï¼šä¸åŒæ“ä½œéœ€è¦å¯¹åº”çš„æƒé™
3. **ä¸šåŠ¡è§„åˆ™éªŒè¯**ï¼šè½¬æ¢å‰æ£€æŸ¥ä¸šåŠ¡çº¦æŸ
4. **äº‹ä»¶å‘å¸ƒ**ï¼šçŠ¶æ€å˜æ›´æ—¶å‘å¸ƒç›¸åº”äº‹ä»¶
5. **å¯æµ‹è¯•æ€§**ï¼šæ¸…æ™°çš„æ¥å£ä¾¿äºå•å…ƒæµ‹è¯•
