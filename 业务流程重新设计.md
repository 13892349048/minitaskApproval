# ä»»åŠ¡å®¡æ‰¹æµä¸šåŠ¡æµç¨‹é‡æ–°è®¾è®¡

## ğŸ”„ ä¸šåŠ¡æµç¨‹åˆ†ç±»

æ ¹æ®ä½ çš„é—®é¢˜ï¼Œæˆ‘é‡æ–°è¯†åˆ«å‡ºäº†ä¸‰ç§ä¸åŒçš„ä¸šåŠ¡æµç¨‹ï¼š

### 1. ä»»åŠ¡ç”³è¯·æµï¼ˆå‘˜å·¥ä¸»åŠ¨ç”³è¯·ï¼‰
```
å‘˜å·¥åˆ›å»ºä»»åŠ¡ç”³è¯· â†’ é¢†å¯¼å®¡æ‰¹ â†’ å‘˜å·¥æ‰§è¡Œ â†’ å‘˜å·¥æäº¤å®Œæˆ â†’ é¢†å¯¼éªŒæ”¶å®¡æ‰¹ â†’ ä»»åŠ¡å…³é—­
```

### 2. ä»»åŠ¡ä¸‹è¾¾æµï¼ˆé¢†å¯¼ä¸»åŠ¨åˆ†é…ï¼‰
```
é¢†å¯¼åˆ›å»ºä»»åŠ¡ â†’ å‘˜å·¥ç¡®è®¤æ¥æ”¶ â†’ å‘˜å·¥æ‰§è¡Œ â†’ å‘˜å·¥æäº¤å®Œæˆ â†’ é¢†å¯¼éªŒæ”¶å®¡æ‰¹ â†’ ä»»åŠ¡å…³é—­
```

### 3. ä»»åŠ¡å§”æ´¾æµï¼ˆå¹³çº§æˆ–è·¨éƒ¨é—¨ï¼‰
```
å‘˜å·¥Aåˆ›å»ºä»»åŠ¡ â†’ éƒ¨é—¨é¢†å¯¼å®¡æ‰¹ â†’ åˆ†é…ç»™å‘˜å·¥B â†’ å‘˜å·¥Bç¡®è®¤ â†’ æ‰§è¡Œ â†’ æäº¤ â†’ éªŒæ”¶ â†’ å…³é—­
```

## ğŸ“‹ é‡æ–°è®¾è®¡çš„çŠ¶æ€æœº

### ä»»åŠ¡ç”³è¯·æµçŠ¶æ€æœº
```mermaid
stateDiagram-v2
    [*] --> Draft : å‘˜å·¥åˆ›å»ºè‰ç¨¿
    
    Draft --> PendingApproval : å‘˜å·¥æäº¤ç”³è¯·
    Draft --> Cancelled : å‘˜å·¥å–æ¶ˆ
    
    PendingApproval --> Approved : é¢†å¯¼æ‰¹å‡†
    PendingApproval --> Rejected : é¢†å¯¼æ‹’ç»
    PendingApproval --> Cancelled : å‘˜å·¥æ’¤å›
    
    Approved --> InProgress : å‘˜å·¥å¼€å§‹æ‰§è¡Œ
    Approved --> Cancelled : å‘˜å·¥æ”¾å¼ƒ
    
    InProgress --> PendingCompletion : å‘˜å·¥æäº¤å®Œæˆ
    InProgress --> Blocked : é‡åˆ°é˜»ç¢
    InProgress --> Cancelled : ä¸­æ­¢æ‰§è¡Œ
    
    Blocked --> InProgress : è§£é™¤é˜»ç¢
    Blocked --> Cancelled : æ— æ³•ç»§ç»­
    
    PendingCompletion --> Completed : é¢†å¯¼éªŒæ”¶é€šè¿‡
    PendingCompletion --> InProgress : é¢†å¯¼è¦æ±‚è¿”å·¥
    
    Rejected --> Draft : å‘˜å·¥ä¿®æ”¹é‡æ
    Rejected --> Cancelled : å‘˜å·¥æ”¾å¼ƒ
    
    Completed --> [*]
    Cancelled --> [*]
```

### ä»»åŠ¡ä¸‹è¾¾æµçŠ¶æ€æœº
```mermaid
stateDiagram-v2
    [*] --> Draft : é¢†å¯¼åˆ›å»ºä»»åŠ¡
    
    Draft --> PendingAcceptance : é¢†å¯¼åˆ†é…ç»™å‘˜å·¥
    Draft --> Cancelled : é¢†å¯¼å–æ¶ˆ
    
    PendingAcceptance --> Accepted : å‘˜å·¥ç¡®è®¤æ¥æ”¶
    PendingAcceptance --> Declined : å‘˜å·¥æ‹’ç»æ¥æ”¶
    PendingAcceptance --> Cancelled : é¢†å¯¼æ’¤å›
    
    Declined --> PendingReassignment : éœ€è¦é‡æ–°åˆ†é…
    PendingReassignment --> PendingAcceptance : åˆ†é…ç»™å…¶ä»–å‘˜å·¥
    PendingReassignment --> Cancelled : é¢†å¯¼å–æ¶ˆä»»åŠ¡
    
    Accepted --> InProgress : å‘˜å·¥å¼€å§‹æ‰§è¡Œ
    Accepted --> Cancelled : å‘˜å·¥ç”³è¯·å–æ¶ˆ
    
    InProgress --> PendingCompletion : å‘˜å·¥æäº¤å®Œæˆ
    InProgress --> Blocked : é‡åˆ°é˜»ç¢
    
    Blocked --> InProgress : è§£é™¤é˜»ç¢
    Blocked --> Cancelled : æ— æ³•ç»§ç»­
    
    PendingCompletion --> Completed : é¢†å¯¼éªŒæ”¶é€šè¿‡
    PendingCompletion --> InProgress : é¢†å¯¼è¦æ±‚è¿”å·¥
    
    Completed --> [*]
    Cancelled --> [*]
```

## ğŸ—ï¸ é‡æ–°è®¾è®¡çš„é¢†åŸŸæ¨¡å‹

### ä»»åŠ¡èšåˆæ ¹é‡æ–°è®¾è®¡
```go
type Task struct {
    ID          TaskID
    Title       string
    Description string
    TaskType    TaskType        // ç”³è¯·ç±»å‹ï¼šSELF_APPLY, ASSIGNED, DELEGATED
    Priority    Priority
    
    // çŠ¶æ€ä¿¡æ¯
    Status      TaskStatus
    
    // å‚ä¸äººå‘˜ï¼ˆæ ¹æ®ä»»åŠ¡ç±»å‹ä¸åŒè€Œä¸åŒï¼‰
    CreatorID   UserID          // ä»»åŠ¡åˆ›å»ºè€…
    ApproverID  UserID          // å®¡æ‰¹äºº
    ExecutorID  UserID          // å®é™…æ‰§è¡Œäºº
    ReviewerID  *UserID         // éªŒæ”¶äººï¼ˆå¯èƒ½ä¸å®¡æ‰¹äººä¸åŒï¼‰
    
    // æ—¶é—´ä¿¡æ¯
    CreatedAt     time.Time
    ApprovedAt    *time.Time
    StartedAt     *time.Time
    SubmittedAt   *time.Time     // æäº¤å®Œæˆæ—¶é—´
    CompletedAt   *time.Time     // éªŒæ”¶å®Œæˆæ—¶é—´
    DueDate       *time.Time
    
    // å®¡æ‰¹å’ŒéªŒæ”¶è®°å½•
    ApprovalRecord   *Approval   // åˆ›å»ºæ—¶çš„å®¡æ‰¹è®°å½•
    CompletionRecord *Approval   // å®Œæˆæ—¶çš„éªŒæ”¶è®°å½•
    
    // é‡æ–°åˆ†é…å†å²
    AssignmentHistory []Assignment
    
    events []DomainEvent
}

// ä»»åŠ¡ç±»å‹æšä¸¾
type TaskType int
const (
    TaskTypeSelfApply TaskType = iota  // å‘˜å·¥ä¸»åŠ¨ç”³è¯·
    TaskTypeAssigned                   // é¢†å¯¼åˆ†é…
    TaskTypeDelegated                  // å§”æ´¾ä»»åŠ¡
)

// é‡æ–°åˆ†é…è®°å½•
type Assignment struct {
    FromUserID  *UserID    // åŸæ‰§è¡Œäººï¼ˆé¦–æ¬¡åˆ†é…æ—¶ä¸ºnilï¼‰
    ToUserID    UserID     // æ–°æ‰§è¡Œäºº
    AssignerID  UserID     // åˆ†é…äºº
    Reason      string     // åˆ†é…åŸå› 
    AssignedAt  time.Time
}
```

### ä¸šåŠ¡æ–¹æ³•é‡æ–°è®¾è®¡
```go
// å‘˜å·¥ç”³è¯·ä»»åŠ¡
func (t *Task) SubmitForApproval(creator *User) error {
    if t.TaskType != TaskTypeSelfApply {
        return errors.New("only self-apply tasks can be submitted for approval")
    }
    
    if t.Status != TaskStatusDraft {
        return errors.New("can only submit draft tasks")
    }
    
    t.Status = TaskStatusPendingApproval
    t.AddEvent(&TaskSubmittedEvent{...})
    return nil
}

// é¢†å¯¼åˆ†é…ä»»åŠ¡ç»™å‘˜å·¥
func (t *Task) AssignToEmployee(assigner *User, executor *User) error {
    if t.TaskType != TaskTypeAssigned {
        return errors.New("only assigned tasks can be assigned to employees")
    }
    
    if t.Status != TaskStatusDraft {
        return errors.New("can only assign draft tasks")
    }
    
    t.ExecutorID = executor.ID
    t.Status = TaskStatusPendingAcceptance
    
    // è®°å½•åˆ†é…å†å²
    assignment := Assignment{
        FromUserID:  nil,  // é¦–æ¬¡åˆ†é…
        ToUserID:    executor.ID,
        AssignerID:  assigner.ID,
        Reason:      "initial assignment",
        AssignedAt:  time.Now(),
    }
    t.AssignmentHistory = append(t.AssignmentHistory, assignment)
    
    t.AddEvent(&TaskAssignedEvent{...})
    return nil
}

// å‘˜å·¥ç¡®è®¤æ¥æ”¶ä»»åŠ¡
func (t *Task) AcceptTask(executor *User) error {
    if t.ExecutorID != executor.ID {
        return errors.New("only assigned executor can accept the task")
    }
    
    if t.Status != TaskStatusPendingAcceptance {
        return errors.New("task is not pending acceptance")
    }
    
    t.Status = TaskStatusAccepted
    t.AddEvent(&TaskAcceptedEvent{...})
    return nil
}

// å‘˜å·¥æ‹’ç»æ¥æ”¶ä»»åŠ¡
func (t *Task) DeclineTask(executor *User, reason string) error {
    if t.ExecutorID != executor.ID {
        return errors.New("only assigned executor can decline the task")
    }
    
    if t.Status != TaskStatusPendingAcceptance {
        return errors.New("task is not pending acceptance")
    }
    
    t.Status = TaskStatusDeclined
    t.AddEvent(&TaskDeclinedEvent{
        TaskID:     t.ID,
        ExecutorID: executor.ID,
        Reason:     reason,
        Timestamp:  time.Now(),
    })
    return nil
}

// é‡æ–°åˆ†é…ä»»åŠ¡
func (t *Task) ReassignTask(assigner *User, newExecutor *User, reason string) error {
    if !assigner.CanReassignTask(t) {
        return errors.New("insufficient permission to reassign task")
    }
    
    oldExecutorID := t.ExecutorID
    t.ExecutorID = newExecutor.ID
    t.Status = TaskStatusPendingAcceptance
    
    // è®°å½•é‡æ–°åˆ†é…å†å²
    assignment := Assignment{
        FromUserID:  oldExecutorID,
        ToUserID:    newExecutor.ID,
        AssignerID:  assigner.ID,
        Reason:      reason,
        AssignedAt:  time.Now(),
    }
    t.AssignmentHistory = append(t.AssignmentHistory, assignment)
    
    t.AddEvent(&TaskReassignedEvent{...})
    return nil
}

// å‘˜å·¥å¼€å§‹æ‰§è¡Œä»»åŠ¡
func (t *Task) StartExecution(executor *User) error {
    if t.ExecutorID != executor.ID {
        return errors.New("only assigned executor can start the task")
    }
    
    if t.Status != TaskStatusAccepted && t.Status != TaskStatusApproved {
        return errors.New("task must be accepted or approved to start")
    }
    
    t.Status = TaskStatusInProgress
    t.StartedAt = &time.Time{}
    *t.StartedAt = time.Now()
    
    t.AddEvent(&TaskStartedEvent{...})
    return nil
}

// å‘˜å·¥æäº¤ä»»åŠ¡å®Œæˆ
func (t *Task) SubmitCompletion(executor *User, result string) error {
    if t.ExecutorID != executor.ID {
        return errors.New("only assigned executor can submit completion")
    }
    
    if t.Status != TaskStatusInProgress {
        return errors.New("task must be in progress to submit completion")
    }
    
    t.Status = TaskStatusPendingCompletion
    now := time.Now()
    t.SubmittedAt = &now
    
    t.AddEvent(&TaskCompletionSubmittedEvent{
        TaskID:     t.ID,
        ExecutorID: executor.ID,
        Result:     result,
        Timestamp:  now,
    })
    return nil
}

// é¢†å¯¼éªŒæ”¶ä»»åŠ¡
func (t *Task) ReviewCompletion(reviewer *User, approved bool, comment string) error {
    if !reviewer.CanReviewTask(t) {
        return errors.New("insufficient permission to review task")
    }
    
    if t.Status != TaskStatusPendingCompletion {
        return errors.New("task is not pending completion review")
    }
    
    if approved {
        t.Status = TaskStatusCompleted
        now := time.Now()
        t.CompletedAt = &now
        
        t.CompletionRecord = &Approval{
            ApproverID: reviewer.ID,
            Action:     ApprovalActionApprove,
            Comment:    comment,
            Timestamp:  now,
        }
        
        t.AddEvent(&TaskCompletedEvent{...})
    } else {
        t.Status = TaskStatusInProgress  // è¿”å·¥
        
        t.CompletionRecord = &Approval{
            ApproverID: reviewer.ID,
            Action:     ApprovalActionReject,
            Comment:    comment,
            Timestamp:  time.Now(),
        }
        
        t.AddEvent(&TaskRejectedForReworkEvent{...})
    }
    
    return nil
}
```

## ğŸ”§ ç®€åŒ–çš„æŠ€æœ¯æ¶æ„

### é—®é¢˜ï¼šæ˜¯å¦ä¸€å®šéœ€è¦Kafkaå’ŒgRPCï¼Ÿ

**ç­”æ¡ˆï¼šä¸ä¸€å®šï¼** è®©æˆ‘æä¾›ä¸€ä¸ªæ¸è¿›å¼çš„æŠ€æœ¯é€‰å‹ï¼š

#### é˜¶æ®µ1ï¼šæœ€ç®€åŒ–ç‰ˆæœ¬ï¼ˆé€‚åˆå­¦ä¹ å’Œå°å›¢é˜Ÿï¼‰
```go
// ä½¿ç”¨å†…å­˜äº‹ä»¶æ€»çº¿
type InMemoryEventBus struct {
    handlers map[string][]EventHandler
    mu       sync.RWMutex
}

// ä½¿ç”¨Redisä½œä¸ºæ¶ˆæ¯é˜Ÿåˆ—
type RedisEventBus struct {
    client *redis.Client
}

func (bus *RedisEventBus) Publish(event DomainEvent) error {
    eventData, _ := json.Marshal(event)
    return bus.client.LPush(context.Background(), "events", eventData).Err()
}

// åªä½¿ç”¨HTTP APIï¼Œä¸éœ€è¦gRPC
type TaskController struct {
    taskAppService *TaskAppService
}
```

#### é˜¶æ®µ2ï¼šä¸­ç­‰è§„æ¨¡ç‰ˆæœ¬ï¼ˆé€‚åˆä¸­å‹å›¢é˜Ÿï¼‰
```go
// ä½¿ç”¨Redis Streamä½œä¸ºæ¶ˆæ¯é˜Ÿåˆ—
type RedisStreamEventBus struct {
    client *redis.Client
}

// æ·»åŠ ç®€å•çš„HTTP API + WebSocketå®æ—¶é€šçŸ¥
type NotificationService struct {
    websocketHub *WebSocketHub
    emailService *EmailService
}
```

#### é˜¶æ®µ3ï¼šä¼ä¸šçº§ç‰ˆæœ¬ï¼ˆå¤§å‹å›¢é˜Ÿå’Œé«˜å¹¶å‘ï¼‰
```go
// ä½¿ç”¨Kafka + gRPC + å¾®æœåŠ¡æ¶æ„
type KafkaEventBus struct {
    producer sarama.SyncProducer
}

type TaskGRPCServer struct {
    taskAppService *TaskAppService
}
```

### æŠ€æœ¯é€‰å‹å¯¹æ¯”è¡¨

| ç‰¹æ€§ | å†…å­˜äº‹ä»¶æ€»çº¿ | Redisæ¶ˆæ¯é˜Ÿåˆ— | Kafka |
|------|-------------|---------------|-------|
| å¤æ‚åº¦ | ä½ | ä¸­ | é«˜ |
| æ€§èƒ½ | é«˜ï¼ˆå†…å­˜ï¼‰ | ä¸­ | é«˜ |
| æŒä¹…åŒ– | æ—  | æœ‰ | æœ‰ |
| åˆ†å¸ƒå¼ | ä¸æ”¯æŒ | æ”¯æŒ | æ”¯æŒ |
| å­¦ä¹ æˆæœ¬ | ä½ | ä¸­ | é«˜ |
| é€‚ç”¨åœºæ™¯ | å­¦ä¹ ã€åŸå‹ | ä¸­å°é¡¹ç›® | å¤§å‹é¡¹ç›® |

## ğŸ“Š é‡æ–°è®¾è®¡çš„å¯ä¿¡åº¦è¯„åˆ†

| è¯„ä¼°ç»´åº¦ | åŸè®¾è®¡ | é‡æ–°è®¾è®¡ | æ”¹è¿›è¯´æ˜ |
|----------|--------|----------|----------|
| **ä¸šåŠ¡å®Œæ•´æ€§** | 6/10 | 9/10 | âœ… è¦†ç›–äº†ä¸‰ç§ä¸šåŠ¡æµç¨‹ï¼ŒåŒ…å«å®ŒæˆéªŒæ”¶ç¯èŠ‚ |
| **æµç¨‹åˆç†æ€§** | 5/10 | 9/10 | âœ… åŒºåˆ†äº†ç”³è¯·æµå’Œä¸‹è¾¾æµï¼Œç¬¦åˆå®é™…ä¸šåŠ¡ |
| **çŠ¶æ€æœºè®¾è®¡** | 7/10 | 9/10 | âœ… å¢åŠ äº†éªŒæ”¶çŠ¶æ€å’Œé‡æ–°åˆ†é…æµç¨‹ |
| **æŠ€æœ¯é€‰å‹** | 6/10 | 8/10 | âœ… æä¾›æ¸è¿›å¼é€‰å‹ï¼Œé¿å…è¿‡åº¦è®¾è®¡ |
| **å®ç”¨æ€§** | 7/10 | 9/10 | âœ… æ›´ç¬¦åˆä¼ä¸šå®é™…å·¥ä½œæµç¨‹ |

## ğŸ¯ è§£å†³æ–¹æ¡ˆæ€»ç»“

### å¯¹ä½ é—®é¢˜çš„å›ç­”ï¼š

1. **ä»»åŠ¡åˆ†é…æµç¨‹**ï¼šé‡æ–°è®¾è®¡äº†ä¸‰ç§ä¸åŒçš„ä¸šåŠ¡æµç¨‹ï¼Œæ˜ç¡®äº†æ¯ç§æµç¨‹çš„å‚ä¸è€…å’ŒçŠ¶æ€è½¬æ¢
2. **å®Œæˆå®¡æ‰¹**ï¼šå¢åŠ äº†ä»»åŠ¡å®Œæˆåçš„éªŒæ”¶å®¡æ‰¹ç¯èŠ‚ï¼ŒåŒ…å«è¿”å·¥æœºåˆ¶
3. **é¢†å¯¼åˆ›å»ºä»»åŠ¡æµ**ï¼šè¿™æ˜¯"ä»»åŠ¡ä¸‹è¾¾æµ"ï¼Œä¸"ä»»åŠ¡ç”³è¯·æµ"æ˜¯ä¸¤ç§ä¸åŒçš„ä¸šåŠ¡æ¨¡å¼
4. **é‡æ–°åˆ†é…**ï¼šè®¾è®¡äº†å®Œæ•´çš„é‡æ–°åˆ†é…æœºåˆ¶ï¼ŒåŒ…å«åˆ†é…å†å²è®°å½•
5. **æŠ€æœ¯é€‰å‹**ï¼šæä¾›äº†æ¸è¿›å¼çš„æŠ€æœ¯é€‰å‹æ–¹æ¡ˆï¼Œä»ç®€å•åˆ°å¤æ‚

è¿™ä¸ªé‡æ–°è®¾è®¡æ›´åŠ è´´è¿‘å®é™…ä¸šåŠ¡åœºæ™¯ï¼ŒæŠ€æœ¯é€‰å‹ä¹Ÿæ›´åŠ åŠ¡å®ã€‚ä½ è§‰å¾—è¿™ä¸ªæ–¹æ¡ˆå¦‚ä½•ï¼Ÿè¿˜æœ‰å“ªäº›åœ°æ–¹éœ€è¦è¿›ä¸€æ­¥è°ƒæ•´ï¼Ÿ
